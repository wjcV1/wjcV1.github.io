import { createVNode as _createVNode } from "vue";
import { defineComponent, Fragment, Comment } from 'vue';
import { internalSizeValidator, props } from './props';
import { toPxNum } from '../utils/elements';
import { isArray } from '@varlet/shared';


import { call, createNamespace } from '../utils/components';
var {
  n,
  classes
} = createNamespace('space');
var internalSizes = {
  mini: [4, 4],
  small: [6, 6],
  normal: [8, 12],
  large: [12, 20]
};
export default defineComponent({
  name: 'VarSpace',
  props,

  setup(props, _ref) {
    var {
      slots
    } = _ref;

    var getSize = (size, isInternalSize) => {
      return isInternalSize ? internalSizes[size] : isArray(size) ? size.map(toPxNum) : [toPxNum(size), toPxNum(size)];
    };

    return () => {
      var _call;

      var {
        inline,
        justify,
        align,
        wrap,
        direction,
        size
      } = props;
      var children = (_call = call(slots.default)) != null ? _call : [];
      var isInternalSize = internalSizeValidator(size);
      var [y, x] = getSize(size, isInternalSize);

      var flatten = vNodes => {
        var result = [];
        vNodes.forEach(vNode => {
          if (vNode.type === Comment) return;

          if (vNode.type === Fragment && isArray(vNode.children)) {
            vNode.children.forEach(item => {
              result.push(item);
            });
            return;
          }

          result.push(vNode);
        });
        return result;
      };

      children = flatten(children);
      var lastIndex = children.length - 1;
      var spacers = children.map((child, index) => {
        var width = direction === 'row' ? undefined : '100%';
        var margin = '0';

        if (direction === 'row') {
          if (justify === 'start' || justify === 'center' || justify === 'end') {
            if (index !== lastIndex) {
              margin = y / 2 + "px " + x + "px " + y / 2 + "px 0";
            } else {
              margin = y / 2 + "px 0";
            }
          } else if (justify === 'space-around') {
            margin = y / 2 + "px " + x / 2 + "px";
          } else if (justify === 'space-between') {
            if (index === 0) {
              margin = y / 2 + "px " + x / 2 + "px " + y / 2 + "px 0";
            } else if (index === lastIndex) {
              margin = y / 2 + "px 0 " + y / 2 + "px " + x / 2 + "px";
            } else {
              margin = y / 2 + "px " + x / 2 + "px";
            }
          }
        }

        if (direction === 'column' && index !== lastIndex) {
          margin = "0 0 " + y + "px 0";
        }

        return _createVNode("div", {
          "style": {
            margin,
            width
          }
        }, [child]);
      });
      return _createVNode("div", {
        "class": classes(n(), 'var--box', [inline, n('--inline')]),
        "style": {
          flexDirection: direction,
          justifyContent: justify,
          alignItems: align,
          flexWrap: wrap ? 'wrap' : 'nowrap',
          margin: direction === 'row' ? "-" + y / 2 + "px 0" : undefined
        }
      }, [spacers]);
    };
  }

});