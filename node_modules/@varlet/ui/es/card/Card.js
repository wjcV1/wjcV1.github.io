function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

import Ripple from '../ripple';
import VarIcon from '../icon';
import VarButton from '../button';
import { ref, defineComponent, watch, computed, nextTick } from 'vue';
import { props } from './props';
import { doubleRaf, toSizeUnit } from '../utils/elements';
import { call, createNamespace } from '../utils/components';
import { useZIndex } from '../context/zIndex';
import { useLock } from '../context/lock';
var {
  n,
  classes
} = createNamespace('card');
var RIPPLE_DELAY = 500;
import { renderSlot as _renderSlot, normalizeClass as _normalizeClass, normalizeStyle as _normalizeStyle, openBlock as _openBlock, createElementBlock as _createElementBlock, createCommentVNode as _createCommentVNode, toDisplayString as _toDisplayString, createElementVNode as _createElementVNode, resolveComponent as _resolveComponent, createVNode as _createVNode, withModifiers as _withModifiers, withCtx as _withCtx, resolveDirective as _resolveDirective, withDirectives as _withDirectives, pushScopeId as _pushScopeId, popScopeId as _popScopeId } from "vue";

var _withScopeId = n => (_pushScopeId(""), n = n(), _popScopeId(), n);

var _hoisted_1 = ["src", "alt"];
export function render(_ctx, _cache) {
  var _component_var_icon = _resolveComponent("var-icon");

  var _component_var_button = _resolveComponent("var-button");

  var _directive_ripple = _resolveDirective("ripple");

  return _withDirectives((_openBlock(), _createElementBlock("div", {
    ref: "card",
    class: _normalizeClass(_ctx.classes(_ctx.n(), [_ctx.isRow, _ctx.n('--layout-row')], [_ctx.elevation, "var-elevation--" + _ctx.elevation, 'var-elevation--1'])),
    style: _normalizeStyle({
      zIndex: _ctx.floated ? _ctx.zIndex : undefined
    }),
    onClick: _cache[0] || (_cache[0] = function () {
      return _ctx.onClick && _ctx.onClick(...arguments);
    })
  }, [_createElementVNode("div", {
    ref: "cardFloater",
    class: _normalizeClass(_ctx.classes(_ctx.n('floater'))),
    style: _normalizeStyle({
      width: _ctx.floaterWidth,
      height: _ctx.floaterHeight,
      top: _ctx.floaterTop,
      left: _ctx.floaterLeft,
      overflow: _ctx.floaterOverflow,
      position: _ctx.floaterPosition,
      transition: _ctx.floated ? "background-color " + _ctx.floatingDuration + "ms, width " + _ctx.floatingDuration + "ms, height " + _ctx.floatingDuration + "ms, top " + _ctx.floatingDuration + "ms, left " + _ctx.floatingDuration + "ms" : undefined
    })
  }, [_renderSlot(_ctx.$slots, "image", {}, () => {
    var _ctx$imageHeight;

    return [_ctx.src ? (_openBlock(), _createElementBlock("img", {
      key: 0,
      class: _normalizeClass(_ctx.n('image')),
      style: _normalizeStyle({
        objectFit: _ctx.fit,
        height: _ctx.toSizeUnit((_ctx$imageHeight = _ctx.imageHeight) != null ? _ctx$imageHeight : _ctx.height),
        width: _ctx.toSizeUnit(_ctx.imageWidth)
      }),
      src: _ctx.src,
      alt: _ctx.alt
    }, null, 14
    /* CLASS, STYLE, PROPS */
    , _hoisted_1)) : _createCommentVNode("v-if", true)];
  }), _createElementVNode("div", {
    class: _normalizeClass(_ctx.n('container'))
  }, [_renderSlot(_ctx.$slots, "title", {}, () => [_ctx.title ? (_openBlock(), _createElementBlock("div", {
    key: 0,
    class: _normalizeClass(_ctx.n('title'))
  }, _toDisplayString(_ctx.title), 3
  /* TEXT, CLASS */
  )) : _createCommentVNode("v-if", true)]), _renderSlot(_ctx.$slots, "subtitle", {}, () => [_ctx.subtitle ? (_openBlock(), _createElementBlock("div", {
    key: 0,
    class: _normalizeClass(_ctx.n('subtitle'))
  }, _toDisplayString(_ctx.subtitle), 3
  /* TEXT, CLASS */
  )) : _createCommentVNode("v-if", true)]), _renderSlot(_ctx.$slots, "description", {}, () => [_ctx.description ? (_openBlock(), _createElementBlock("div", {
    key: 0,
    class: _normalizeClass(_ctx.n('description'))
  }, _toDisplayString(_ctx.description), 3
  /* TEXT, CLASS */
  )) : _createCommentVNode("v-if", true)]), _ctx.$slots.extra ? (_openBlock(), _createElementBlock("div", {
    key: 0,
    class: _normalizeClass(_ctx.n('footer'))
  }, [_renderSlot(_ctx.$slots, "extra")], 2
  /* CLASS */
  )) : _createCommentVNode("v-if", true), _ctx.$slots.content && !_ctx.isRow ? (_openBlock(), _createElementBlock("div", {
    key: 1,
    class: _normalizeClass(_ctx.n('content')),
    style: _normalizeStyle({
      height: _ctx.contentHeight,
      opacity: _ctx.opacity,
      transition: "opacity " + _ctx.floatingDuration * 2 + "ms"
    })
  }, [_renderSlot(_ctx.$slots, "content")], 6
  /* CLASS, STYLE */
  )) : _createCommentVNode("v-if", true)], 2
  /* CLASS */
  ), _ctx.showFloatingButtons ? (_openBlock(), _createElementBlock("div", {
    key: 0,
    class: _normalizeClass(_ctx.classes(_ctx.n('floating-buttons'), 'var--box')),
    style: _normalizeStyle({
      zIndex: _ctx.zIndex,
      opacity: _ctx.opacity,
      transition: "opacity " + _ctx.floatingDuration * 2 + "ms"
    })
  }, [_renderSlot(_ctx.$slots, "close-button", {}, () => [_createVNode(_component_var_button, {
    "var-card-cover": "",
    round: "",
    class: _normalizeClass(_ctx.classes(_ctx.n('close-button'), 'var-elevation--6')),
    onClick: _withModifiers(_ctx.close, ["stop"])
  }, {
    default: _withCtx(() => [_createVNode(_component_var_icon, {
      "var-card-cover": "",
      name: "window-close",
      class: _normalizeClass(_ctx.n('close-button-icon'))
    }, null, 8
    /* PROPS */
    , ["class"])]),
    _: 1
    /* STABLE */

  }, 8
  /* PROPS */
  , ["class", "onClick"])])], 6
  /* CLASS, STYLE */
  )) : _createCommentVNode("v-if", true)], 6
  /* CLASS, STYLE */
  ), _createElementVNode("div", {
    class: _normalizeClass(_ctx.n('holder')),
    style: _normalizeStyle({
      width: _ctx.holderWidth,
      height: _ctx.holderHeight
    })
  }, null, 6
  /* CLASS, STYLE */
  )], 6
  /* CLASS, STYLE */
  )), [[_directive_ripple, {
    disabled: !_ctx.ripple || _ctx.floater
  }]]);
}
export default defineComponent({
  render,
  name: 'VarCard',
  directives: {
    Ripple
  },
  components: {
    VarIcon,
    VarButton
  },
  props,

  setup(props) {
    var card = ref(null);
    var cardFloater = ref(null);
    var holderWidth = ref('auto');
    var holderHeight = ref('auto');
    var floaterWidth = ref('100%');
    var floaterHeight = ref('100%');
    var floaterTop = ref('auto');
    var floaterLeft = ref('auto');
    var floaterPosition = ref(undefined);
    var floaterOverflow = ref('hidden');
    var contentHeight = ref('0px');
    var opacity = ref('0');
    var {
      zIndex
    } = useZIndex(() => props.floating, 1);
    var isRow = computed(() => props.layout === 'row');
    var showFloatingButtons = ref(false);
    var floated = ref(false);
    useLock(() => props.floating, () => isRow);
    var dropdownFloaterTop = 'auto';
    var dropdownFloaterLeft = 'auto';
    var dropper = null;
    var floater = ref(null);

    var floating = /*#__PURE__*/function () {
      var _ref = _asyncToGenerator(function* () {
        clearTimeout(floater.value);
        clearTimeout(dropper);
        floater.value = null;
        floater.value = setTimeout( /*#__PURE__*/_asyncToGenerator(function* () {
          var {
            width,
            height,
            left,
            top
          } = card.value.getBoundingClientRect();
          holderWidth.value = toSizeUnit(width);
          holderHeight.value = toSizeUnit(height);
          floaterWidth.value = holderWidth.value;
          floaterHeight.value = holderHeight.value;
          floaterTop.value = toSizeUnit(top);
          floaterLeft.value = toSizeUnit(left);
          floaterPosition.value = 'fixed';
          dropdownFloaterTop = floaterTop.value;
          dropdownFloaterLeft = floaterLeft.value;
          showFloatingButtons.value = true;
          yield doubleRaf();
          floaterTop.value = '0';
          floaterLeft.value = '0';
          floaterWidth.value = '100vw';
          floaterHeight.value = '100vh';
          contentHeight.value = 'auto';
          opacity.value = '1';
          floaterOverflow.value = 'auto';
          floated.value = true;
        }), props.ripple ? RIPPLE_DELAY : 0);
      });

      return function floating() {
        return _ref.apply(this, arguments);
      };
    }();

    var dropdown = () => {
      clearTimeout(dropper);
      clearTimeout(floater.value);
      floater.value = null;
      floaterWidth.value = holderWidth.value;
      floaterHeight.value = holderHeight.value;
      floaterTop.value = dropdownFloaterTop;
      floaterLeft.value = dropdownFloaterLeft;
      contentHeight.value = '0px';
      opacity.value = '0';
      showFloatingButtons.value = false;
      dropper = setTimeout(() => {
        holderWidth.value = 'auto';
        holderHeight.value = 'auto';
        floaterWidth.value = '100%';
        floaterHeight.value = '100%';
        floaterTop.value = 'auto';
        floaterLeft.value = 'auto';
        dropdownFloaterTop = 'auto';
        dropdownFloaterLeft = 'auto';
        floaterOverflow.value = 'hidden';
        floaterPosition.value = undefined;
        floated.value = false;
      }, props.floatingDuration);
    };

    var close = () => {
      call(props['onUpdate:floating'], false);
    };

    watch(() => props.floating, value => {
      if (isRow.value) return;
      nextTick(() => {
        value ? floating() : dropdown();
      });
    }, {
      immediate: true
    });
    return {
      n,
      classes,
      toSizeUnit,
      card,
      cardFloater,
      holderWidth,
      holderHeight,
      floater,
      floaterWidth,
      floaterHeight,
      floaterTop,
      floaterLeft,
      floaterPosition,
      floaterOverflow,
      contentHeight,
      opacity,
      zIndex,
      isRow,
      close,
      showFloatingButtons,
      floated
    };
  }

});