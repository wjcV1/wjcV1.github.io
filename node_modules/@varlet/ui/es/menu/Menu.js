import { isVNode as _isVNode, withDirectives as _withDirectives, createVNode as _createVNode, vShow as _vShow } from "vue";

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

import { defineComponent, ref, computed, watch, onMounted, onUnmounted, Transition, Teleport, nextTick } from 'vue';
import { props } from './props';
import { getLeft, getTop, toSizeUnit } from '../utils/elements';
import { useZIndex } from '../context/zIndex';
import { call, createNamespace, exposeApis, useTeleport } from '../utils/components';




function _isSlot(s) {
  return typeof s === 'function' || Object.prototype.toString.call(s) === '[object Object]' && !_isVNode(s);
}

var {
  n,
  classes
} = createNamespace('menu');
export default defineComponent({
  name: 'VarMenu',
  props,

  setup(props, _ref) {
    var {
      slots
    } = _ref;
    var host = ref(null);
    var menu = ref(null);
    var to = ref();
    var top = ref(0);
    var left = ref(0);
    var {
      zIndex
    } = useZIndex(() => props.show, 1);
    var {
      disabled
    } = useTeleport();
    var clickSelf = false;

    var computeTop = alignment => {
      return alignment === 'top' ? getTop(host.value) : getTop(host.value) - menu.value.offsetHeight;
    };

    var handleClick = () => {
      clickSelf = true;
    };

    var handleMenuClose = () => {
      if (clickSelf) {
        clickSelf = false;
        return;
      }

      if (!props.show) {
        return;
      }

      call(props['onUpdate:show'], false);
    }; // expose


    var resize = () => {
      top.value = computeTop(props.alignment);
      left.value = getLeft(host.value);
    }; // Transition style use computed place here


    var transitionStyle = computed(() => {
      return {
        top: "calc(" + top.value + "px + " + toSizeUnit(props.offsetY) + ")",
        left: "calc(" + left.value + "px + " + toSizeUnit(props.offsetX) + ")",
        zIndex: zIndex.value
      };
    });

    var renderTransition = () => _createVNode(Transition, {
      "name": n(),
      "onAfterEnter": props.onOpened,
      "onAfterLeave": props.onClosed
    }, {
      default: () => [_withDirectives(_createVNode("div", {
        "class": classes(n('menu'), 'var-elevation--3'),
        "ref": menu,
        "style": transitionStyle.value,
        "onClick": event => {
          event.stopPropagation();
        }
      }, [call(slots.menu)]), [[_vShow, props.show]])]
    });

    watch(() => props.alignment, resize);
    watch(() => props.show, /*#__PURE__*/function () {
      var _ref2 = _asyncToGenerator(function* (newValue) {
        var {
          onOpen,
          onClose
        } = props;

        if (newValue) {
          yield nextTick();
          resize();
        }

        newValue ? call(onOpen) : call(onClose);
      });

      return function (_x) {
        return _ref2.apply(this, arguments);
      };
    }());
    watch(() => props.teleport, newValue => {
      to.value = newValue;
    });
    onMounted(() => {
      // Synchronously transfer the state to the mount hook to support server-side rendering to prevent hydration errors
      to.value = props.teleport;
      resize();
      document.addEventListener('click', handleMenuClose);
      window.addEventListener('resize', resize);
    });
    onUnmounted(() => {
      document.removeEventListener('click', handleMenuClose);
      window.removeEventListener('resize', resize);
    });
    exposeApis({
      resize
    });
    return () => {
      var _slot;

      return _createVNode("div", {
        "class": n(),
        "ref": host,
        "onClick": handleClick
      }, [call(slots.default), to.value ? _createVNode(Teleport, {
        "to": to.value,
        "disabled": disabled.value
      }, _isSlot(_slot = renderTransition()) ? _slot : {
        default: () => [_slot]
      }) : renderTransition()]);
    };
  }

});