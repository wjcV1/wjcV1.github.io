"use strict";

exports.__esModule = true;
exports.default = void 0;
exports.render = render;

var _swipe = _interopRequireDefault(require("../swipe"));

var _swipeItem = _interopRequireDefault(require("../swipe-item"));

var _icon = _interopRequireDefault(require("../icon"));

var _popup = _interopRequireDefault(require("../popup"));

var _vue = require("vue");

var _props = require("./props");

var _shared = require("@varlet/shared");

var _components = require("../utils/components");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var {
  n,
  classes
} = (0, _components.createNamespace)('image-preview');
var DISTANCE_OFFSET = 12;
var EVENT_DELAY = 200;
var TAP_DELAY = 350;
var ANIMATION_DURATION = 200;

var _withScopeId = n => ((0, _vue.pushScopeId)(""), n = n(), (0, _vue.popScopeId)(), n);

var _hoisted_1 = ["src", "alt"];

function render(_ctx, _cache) {
  var _component_var_swipe_item = (0, _vue.resolveComponent)("var-swipe-item");

  var _component_var_swipe = (0, _vue.resolveComponent)("var-swipe");

  var _component_var_icon = (0, _vue.resolveComponent)("var-icon");

  var _component_var_popup = (0, _vue.resolveComponent)("var-popup");

  return (0, _vue.openBlock)(), (0, _vue.createBlock)(_component_var_popup, {
    class: (0, _vue.normalizeClass)(_ctx.n('popup')),
    "var-image-preview-cover": "",
    transition: "var-fade",
    show: _ctx.popupShow,
    overlay: false,
    "close-on-click-overlay": false,
    "lock-scroll": _ctx.lockScroll,
    teleport: _ctx.teleport,
    onOpen: _ctx.onOpen,
    onClose: _ctx.onClose,
    onClosed: _ctx.onClosed,
    onOpened: _ctx.onOpened,
    onRouteChange: _ctx.onRouteChange
  }, {
    default: (0, _vue.withCtx)(() => [(0, _vue.createVNode)(_component_var_swipe, (0, _vue.mergeProps)({
      class: _ctx.n('swipe'),
      "var-image-preview-cover": "",
      touchable: _ctx.canSwipe,
      indicator: _ctx.indicator && _ctx.images.length > 1,
      "initial-index": _ctx.initialIndex,
      loop: _ctx.loop,
      onChange: _ctx.onChange
    }, _ctx.$attrs), {
      default: (0, _vue.withCtx)(() => [((0, _vue.openBlock)(true), (0, _vue.createElementBlock)(_vue.Fragment, null, (0, _vue.renderList)(_ctx.images, image => {
        return (0, _vue.openBlock)(), (0, _vue.createBlock)(_component_var_swipe_item, {
          class: (0, _vue.normalizeClass)(_ctx.n('swipe-item')),
          "var-image-preview-cover": "",
          key: image
        }, {
          default: (0, _vue.withCtx)(() => [(0, _vue.createElementVNode)("div", {
            class: (0, _vue.normalizeClass)(_ctx.n('zoom-container')),
            style: (0, _vue.normalizeStyle)({
              transform: "scale(" + _ctx.scale + ") translate(" + _ctx.translateX + "px, " + _ctx.translateY + "px)",
              transitionTimingFunction: _ctx.transitionTimingFunction,
              transitionDuration: _ctx.transitionDuration
            }),
            onTouchstart: _cache[0] || (_cache[0] = function () {
              return _ctx.handleTouchstart && _ctx.handleTouchstart(...arguments);
            }),
            onTouchmove: _cache[1] || (_cache[1] = function () {
              return _ctx.handleTouchmove && _ctx.handleTouchmove(...arguments);
            }),
            onTouchend: _cache[2] || (_cache[2] = function () {
              return _ctx.handleTouchend && _ctx.handleTouchend(...arguments);
            })
          }, [(0, _vue.createElementVNode)("img", {
            class: (0, _vue.normalizeClass)(_ctx.n('image')),
            src: image,
            alt: image
          }, null, 10
          /* CLASS, PROPS */
          , _hoisted_1)], 38
          /* CLASS, STYLE, HYDRATE_EVENTS */
          )]),
          _: 2
          /* DYNAMIC */

        }, 1032
        /* PROPS, DYNAMIC_SLOTS */
        , ["class"]);
      }), 128
      /* KEYED_FRAGMENT */
      ))]),
      indicator: (0, _vue.withCtx)(_ref => {
        var {
          index,
          length
        } = _ref;
        return [(0, _vue.renderSlot)(_ctx.$slots, "indicator", {
          index: index,
          length: length
        }, () => [_ctx.indicator && _ctx.images.length > 1 ? ((0, _vue.openBlock)(), (0, _vue.createElementBlock)("div", {
          key: 0,
          class: (0, _vue.normalizeClass)(_ctx.n('indicators'))
        }, (0, _vue.toDisplayString)(index + 1) + " / " + (0, _vue.toDisplayString)(length), 3
        /* TEXT, CLASS */
        )) : (0, _vue.createCommentVNode)("v-if", true)])];
      }),
      _: 3
      /* FORWARDED */

    }, 16
    /* FULL_PROPS */
    , ["class", "touchable", "indicator", "initial-index", "loop", "onChange"]), (0, _vue.renderSlot)(_ctx.$slots, "close-icon", {}, () => [_ctx.closeable ? ((0, _vue.openBlock)(), (0, _vue.createBlock)(_component_var_icon, {
      key: 0,
      class: (0, _vue.normalizeClass)(_ctx.n('close-icon')),
      name: "close-circle",
      "var-image-preview-cover": "",
      onClick: _ctx.close
    }, null, 8
    /* PROPS */
    , ["class", "onClick"])) : (0, _vue.createCommentVNode)("v-if", true)]), (0, _vue.createElementVNode)("div", {
      class: (0, _vue.normalizeClass)(_ctx.n('extra'))
    }, [(0, _vue.renderSlot)(_ctx.$slots, "extra")], 2
    /* CLASS */
    )]),
    _: 3
    /* FORWARDED */

  }, 8
  /* PROPS */
  , ["class", "show", "lock-scroll", "teleport", "onOpen", "onClose", "onClosed", "onOpened", "onRouteChange"]);
}

var _default = (0, _vue.defineComponent)({
  render,
  name: 'VarImagePreview',
  components: {
    VarSwipe: _swipe.default,
    VarSwipeItem: _swipeItem.default,
    VarPopup: _popup.default,
    VarIcon: _icon.default
  },
  inheritAttrs: false,
  props: _props.props,

  setup(props) {
    var popupShow = (0, _vue.ref)(false);
    var initialIndex = (0, _vue.computed)(() => {
      var {
        images,
        current
      } = props;
      var index = images.findIndex(image => image === current);
      return index >= 0 ? index : 0;
    });
    var scale = (0, _vue.ref)(1);
    var translateX = (0, _vue.ref)(0);
    var translateY = (0, _vue.ref)(0);
    var transitionTimingFunction = (0, _vue.ref)(undefined);
    var transitionDuration = (0, _vue.ref)(undefined);
    var canSwipe = (0, _vue.ref)(true);
    var startTouch = null;
    var prevTouch = null;
    var checker = null;

    var getDistance = (touch, target) => {
      var {
        clientX: touchX,
        clientY: touchY
      } = touch;
      var {
        clientX: targetX,
        clientY: targetY
      } = target;
      return Math.abs(Math.sqrt(Math.pow(targetX - touchX, 2) + Math.pow(targetY - touchY, 2)));
    };

    var createVarTouch = (touches, target) => ({
      clientX: touches.clientX,
      clientY: touches.clientY,
      timestamp: Date.now(),
      target
    });

    var zoomIn = () => {
      scale.value = (0, _shared.toNumber)(props.zoom);
      canSwipe.value = false;
      prevTouch = null;
      window.setTimeout(() => {
        transitionTimingFunction.value = 'linear';
        transitionDuration.value = '0s';
      }, ANIMATION_DURATION);
    };

    var zoomOut = () => {
      scale.value = 1;
      translateX.value = 0;
      translateY.value = 0;
      canSwipe.value = true;
      prevTouch = null;
      transitionTimingFunction.value = undefined;
      transitionDuration.value = undefined;
    };

    var isDoubleTouch = currentTouch => {
      if (!prevTouch) {
        return false;
      }

      return getDistance(prevTouch, currentTouch) <= DISTANCE_OFFSET && currentTouch.timestamp - prevTouch.timestamp <= EVENT_DELAY && prevTouch.target === currentTouch.target;
    };

    var isTapTouch = target => {
      if (!target || !startTouch || !prevTouch) {
        return false;
      }

      return getDistance(startTouch, prevTouch) <= DISTANCE_OFFSET && Date.now() - prevTouch.timestamp < TAP_DELAY && (target === startTouch.target || target.parentNode === startTouch.target);
    };

    var handleTouchend = event => {
      checker = window.setTimeout(() => {
        isTapTouch(event.target) && close();
        startTouch = null;
      }, EVENT_DELAY);
    };

    var handleTouchstart = event => {
      checker && window.clearTimeout(checker);
      var {
        touches
      } = event;
      var currentTouch = createVarTouch(touches[0], event.currentTarget);
      startTouch = currentTouch;

      if (isDoubleTouch(currentTouch)) {
        scale.value > 1 ? zoomOut() : zoomIn();
        return;
      }

      prevTouch = currentTouch;
    };

    var getZoom = target => {
      var {
        offsetWidth,
        offsetHeight
      } = target;
      var {
        naturalWidth,
        naturalHeight
      } = target.querySelector('.var-image-preview__image');
      return {
        width: offsetWidth,
        height: offsetHeight,
        imageRadio: naturalHeight / naturalWidth,
        rootRadio: offsetHeight / offsetWidth,
        zoom: (0, _shared.toNumber)(props.zoom)
      };
    };

    var getLimitX = target => {
      var {
        zoom,
        imageRadio,
        rootRadio,
        width,
        height
      } = getZoom(target);

      if (!imageRadio) {
        return 0;
      }

      var displayWidth = imageRadio > rootRadio ? height / imageRadio : width;
      return Math.max(0, (zoom * displayWidth - width) / 2) / zoom;
    };

    var getLimitY = target => {
      var {
        zoom,
        imageRadio,
        rootRadio,
        width,
        height
      } = getZoom(target);

      if (!imageRadio) {
        return 0;
      }

      var displayHeight = imageRadio > rootRadio ? height : width * imageRadio;
      return Math.max(0, (zoom * displayHeight - height) / 2) / zoom;
    };

    var getMoveTranslate = (current, move, limit) => {
      if (current + move >= limit) {
        return limit;
      }

      if (current + move <= -limit) {
        return -limit;
      }

      return current + move;
    };

    var handleTouchmove = event => {
      if (!prevTouch) {
        return;
      }

      var target = event.currentTarget;
      var {
        touches
      } = event;
      var currentTouch = createVarTouch(touches[0], target);

      if (scale.value > 1) {
        var moveX = currentTouch.clientX - prevTouch.clientX;
        var moveY = currentTouch.clientY - prevTouch.clientY;
        var limitX = getLimitX(target);
        var limitY = getLimitY(target);
        translateX.value = getMoveTranslate(translateX.value, moveX, limitX);
        translateY.value = getMoveTranslate(translateY.value, moveY, limitY);
      }

      prevTouch = currentTouch;
    };

    var close = () => {
      if (scale.value > 1) {
        zoomOut();
        setTimeout(() => (0, _components.call)(props['onUpdate:show'], false), ANIMATION_DURATION);
        return;
      }

      (0, _components.call)(props['onUpdate:show'], false);
    };

    (0, _vue.watch)(() => props.show, newValue => {
      popupShow.value = newValue;
    }, {
      immediate: true
    });
    return {
      n,
      classes,
      initialIndex,
      popupShow,
      scale,
      translateX,
      translateY,
      canSwipe,
      transitionTimingFunction,
      transitionDuration,
      handleTouchstart,
      handleTouchmove,
      handleTouchend,
      close
    };
  }

});

exports.default = _default;