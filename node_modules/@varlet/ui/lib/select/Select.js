"use strict";

exports.__esModule = true;
exports.default = void 0;
exports.render = render;

var _icon = _interopRequireDefault(require("../icon"));

var _menu = _interopRequireDefault(require("../menu"));

var _chip = _interopRequireDefault(require("../chip"));

var _formDetails = _interopRequireDefault(require("../form-details"));

var _vue = require("vue");

var _shared = require("@varlet/shared");

var _props = require("./props");

var _components = require("../utils/components");

var _provide = require("./provide");

var _provide2 = require("../form/provide");

var _elements = require("../utils/elements");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var {
  n,
  classes
} = (0, _components.createNamespace)('select');

var _withScopeId = n => ((0, _vue.pushScopeId)(""), n = n(), (0, _vue.popScopeId)(), n);

var _hoisted_1 = {
  key: 0
};
var _hoisted_2 = {
  key: 1
};

function render(_ctx, _cache) {
  var _component_var_chip = (0, _vue.resolveComponent)("var-chip");

  var _component_var_icon = (0, _vue.resolveComponent)("var-icon");

  var _component_var_menu = (0, _vue.resolveComponent)("var-menu");

  var _component_var_form_details = (0, _vue.resolveComponent)("var-form-details");

  return (0, _vue.openBlock)(), (0, _vue.createElementBlock)("div", {
    class: (0, _vue.normalizeClass)(_ctx.classes(_ctx.n(), 'var--box', [_ctx.formDisabled || _ctx.disabled, _ctx.n('--disabled')])),
    onClick: _cache[3] || (_cache[3] = function () {
      return _ctx.handleClick && _ctx.handleClick(...arguments);
    })
  }, [(0, _vue.createElementVNode)("div", {
    class: (0, _vue.normalizeClass)(_ctx.classes(_ctx.n('controller'), [_ctx.isFocus, _ctx.n('--focus')], [_ctx.errorMessage, _ctx.n('--error')], [_ctx.formDisabled || _ctx.disabled, _ctx.n('--disabled')])),
    style: (0, _vue.normalizeStyle)({
      color: !_ctx.errorMessage ? _ctx.isFocus ? _ctx.focusColor : _ctx.blurColor : undefined
    })
  }, [(0, _vue.createElementVNode)("div", {
    class: (0, _vue.normalizeClass)(_ctx.classes(_ctx.n('icon'), [!_ctx.hint, _ctx.n('--non-hint')]))
  }, [(0, _vue.renderSlot)(_ctx.$slots, "prepend-icon")], 2
  /* CLASS */
  ), (0, _vue.createVNode)(_component_var_menu, {
    class: (0, _vue.normalizeClass)(_ctx.n('menu')),
    "var-select-cover": "",
    "offset-y": _ctx.offsetY,
    show: _ctx.isFocus,
    "onUpdate:show": _cache[2] || (_cache[2] = $event => _ctx.isFocus = $event),
    onClose: _ctx.handleBlur
  }, {
    menu: (0, _vue.withCtx)(() => [(0, _vue.createElementVNode)("div", {
      ref: "menuEl",
      class: (0, _vue.normalizeClass)(_ctx.n('scroller'))
    }, [(0, _vue.renderSlot)(_ctx.$slots, "default")], 2
    /* CLASS */
    )]),
    default: (0, _vue.withCtx)(() => [(0, _vue.createElementVNode)("div", {
      class: (0, _vue.normalizeClass)(_ctx.classes(_ctx.n('wrap'), [!_ctx.hint, _ctx.n('--non-hint')])),
      ref: "wrapEl",
      onClick: _cache[1] || (_cache[1] = function () {
        return _ctx.handleFocus && _ctx.handleFocus(...arguments);
      })
    }, [(0, _vue.createElementVNode)("div", {
      class: (0, _vue.normalizeClass)(_ctx.classes(_ctx.n('select'), [_ctx.errorMessage, _ctx.n('--error')], [_ctx.formDisabled || _ctx.disabled, _ctx.n('--disabled')])),
      style: (0, _vue.normalizeStyle)({
        textAlign: _ctx.textAlign,
        color: _ctx.textColor
      })
    }, [_ctx.multiple ? ((0, _vue.openBlock)(), (0, _vue.createElementBlock)("div", _hoisted_1, [_ctx.chip ? ((0, _vue.openBlock)(), (0, _vue.createElementBlock)("div", {
      key: 0,
      class: (0, _vue.normalizeClass)(_ctx.n('chips'))
    }, [((0, _vue.openBlock)(true), (0, _vue.createElementBlock)(_vue.Fragment, null, (0, _vue.renderList)(_ctx.labels, l => {
      return (0, _vue.openBlock)(), (0, _vue.createBlock)(_component_var_chip, {
        class: (0, _vue.normalizeClass)(_ctx.n('chip')),
        "var-select-cover": "",
        closable: "",
        size: "small",
        type: _ctx.errorMessage ? 'danger' : undefined,
        key: l,
        onClick: _cache[0] || (_cache[0] = (0, _vue.withModifiers)(() => {}, ["stop"])),
        onClose: () => _ctx.handleClose(l)
      }, {
        default: (0, _vue.withCtx)(() => [(0, _vue.createTextVNode)((0, _vue.toDisplayString)(l), 1
        /* TEXT */
        )]),
        _: 2
        /* DYNAMIC */

      }, 1032
      /* PROPS, DYNAMIC_SLOTS */
      , ["class", "type", "onClose"]);
    }), 128
    /* KEYED_FRAGMENT */
    ))], 2
    /* CLASS */
    )) : ((0, _vue.openBlock)(), (0, _vue.createElementBlock)("div", {
      key: 1,
      class: (0, _vue.normalizeClass)(_ctx.n('values'))
    }, (0, _vue.toDisplayString)(_ctx.labels.join(_ctx.separator)), 3
    /* TEXT, CLASS */
    ))])) : ((0, _vue.openBlock)(), (0, _vue.createElementBlock)("span", _hoisted_2, (0, _vue.toDisplayString)(_ctx.label), 1
    /* TEXT */
    )), (0, _vue.createVNode)(_component_var_icon, {
      class: (0, _vue.normalizeClass)(_ctx.classes(_ctx.n('arrow'), [_ctx.isFocus, _ctx.n('--arrow-rotate')])),
      "var-select-cover": "",
      name: "menu-down",
      transition: 300
    }, null, 8
    /* PROPS */
    , ["class"])], 6
    /* CLASS, STYLE */
    ), (0, _vue.createElementVNode)("label", {
      class: (0, _vue.normalizeClass)(_ctx.classes(_ctx.n('placeholder'), 'var--ellipsis', [_ctx.isFocus, _ctx.n('--focus')], [_ctx.errorMessage, _ctx.n('--error')], [_ctx.formDisabled || _ctx.disabled, _ctx.n('--disabled')], _ctx.computePlaceholderState(), [!_ctx.hint, _ctx.n('--placeholder-non-hint')])),
      style: (0, _vue.normalizeStyle)({
        color: !_ctx.errorMessage ? _ctx.isFocus ? _ctx.focusColor : _ctx.blurColor : undefined
      })
    }, (0, _vue.toDisplayString)(_ctx.placeholder), 7
    /* TEXT, CLASS, STYLE */
    )], 2
    /* CLASS */
    )]),
    _: 3
    /* FORWARDED */

  }, 8
  /* PROPS */
  , ["class", "offset-y", "show", "onClose"]), (0, _vue.createElementVNode)("div", {
    class: (0, _vue.normalizeClass)(_ctx.classes(_ctx.n('icon'), [!_ctx.hint, _ctx.n('--non-hint')]))
  }, [(0, _vue.renderSlot)(_ctx.$slots, "append-icon", {}, () => [_ctx.clearable ? ((0, _vue.openBlock)(), (0, _vue.createBlock)(_component_var_icon, {
    key: 0,
    class: (0, _vue.normalizeClass)(_ctx.n('clear-icon')),
    name: "close-circle",
    size: "14px",
    onClick: _ctx.handleClear
  }, null, 8
  /* PROPS */
  , ["class", "onClick"])) : (0, _vue.createCommentVNode)("v-if", true)])], 2
  /* CLASS */
  )], 6
  /* CLASS, STYLE */
  ), _ctx.line ? ((0, _vue.openBlock)(), (0, _vue.createElementBlock)("div", {
    key: 0,
    class: (0, _vue.normalizeClass)(_ctx.classes(_ctx.n('line'), [_ctx.formDisabled || _ctx.disabled, _ctx.n('--line-disabled')], [_ctx.errorMessage, _ctx.n('--line-error')])),
    style: (0, _vue.normalizeStyle)({
      background: !_ctx.errorMessage ? _ctx.blurColor : undefined
    })
  }, [(0, _vue.createElementVNode)("div", {
    class: (0, _vue.normalizeClass)(_ctx.classes(_ctx.n('dot'), [_ctx.isFocus, _ctx.n('--spread')], [_ctx.formDisabled || _ctx.disabled, _ctx.n('--line-disabled')], [_ctx.errorMessage, _ctx.n('--line-error')])),
    style: (0, _vue.normalizeStyle)({
      background: !_ctx.errorMessage ? _ctx.focusColor : undefined
    })
  }, null, 6
  /* CLASS, STYLE */
  )], 6
  /* CLASS, STYLE */
  )) : (0, _vue.createCommentVNode)("v-if", true), (0, _vue.createVNode)(_component_var_form_details, {
    "error-message": _ctx.errorMessage
  }, null, 8
  /* PROPS */
  , ["error-message"])], 2
  /* CLASS */
  );
}

var _default = (0, _vue.defineComponent)({
  render,
  name: 'VarSelect',
  components: {
    VarIcon: _icon.default,
    VarMenu: _menu.default,
    VarChip: _chip.default,
    VarFormDetails: _formDetails.default
  },
  props: _props.props,

  setup(props) {
    var wrapEl = (0, _vue.ref)(null);
    var isFocus = (0, _vue.ref)(false);
    var multiple = (0, _vue.computed)(() => props.multiple);
    var focusColor = (0, _vue.computed)(() => props.focusColor);
    var label = (0, _vue.ref)('');
    var labels = (0, _vue.ref)([]);
    var wrapWidth = (0, _vue.ref)('0px');
    var offsetY = (0, _vue.ref)(0);
    var {
      bindForm,
      form
    } = (0, _provide2.useForm)();
    var {
      length,
      options,
      bindOptions
    } = (0, _provide.useOptions)();
    var {
      errorMessage,
      validateWithTrigger: vt,
      validate: v,
      // expose
      resetValidation
    } = (0, _components.useValidation)();
    var menuEl = (0, _vue.ref)(null);

    var computeLabel = () => {
      var {
        multiple,
        modelValue
      } = props;

      if (multiple) {
        var rawModelValue = modelValue;
        labels.value = rawModelValue.map(findLabel);
      }

      if (!multiple && !(0, _shared.isEmpty)(modelValue)) {
        label.value = findLabel(modelValue);
      }

      if (!multiple && (0, _shared.isEmpty)(modelValue)) {
        label.value = '';
      }
    };

    var validateWithTrigger = trigger => {
      (0, _vue.nextTick)(() => {
        var {
          validateTrigger,
          rules,
          modelValue
        } = props;
        vt(validateTrigger, trigger, rules, modelValue);
      });
    };

    var findValueOrLabel = _ref => {
      var {
        value,
        label
      } = _ref;

      if (value.value != null) {
        return value.value;
      }

      return label.value;
    };

    var findLabel = modelValue => {
      var _option$label$value, _option;

      var option = options.find(_ref2 => {
        var {
          value
        } = _ref2;
        return value.value === modelValue;
      });

      if (!option) {
        option = options.find(_ref3 => {
          var {
            label
          } = _ref3;
          return label.value === modelValue;
        });
      }

      return (_option$label$value = (_option = option) == null ? void 0 : _option.label.value) != null ? _option$label$value : '';
    };

    var computePlaceholderState = () => {
      var {
        hint,
        modelValue
      } = props;

      if (!hint && !(0, _shared.isEmpty)(modelValue)) {
        return n('--placeholder-hidden');
      }

      if (hint && (!(0, _shared.isEmpty)(modelValue) || isFocus.value)) {
        return n('--placeholder-hint');
      }
    };

    var getWrapWidth = () => {
      return wrapEl.value && window.getComputedStyle(wrapEl.value).width || '0px';
    };

    var getOffsetY = () => {
      var paddingTop = wrapEl.value && window.getComputedStyle(wrapEl.value).paddingTop || '0px';
      return (0, _elements.toPxNum)(paddingTop) * 1.5;
    };

    var handleFocus = () => {
      var {
        disabled,
        readonly,
        onFocus
      } = props;

      if (form != null && form.disabled.value || form != null && form.readonly.value || disabled || readonly) {
        return;
      }

      wrapWidth.value = getWrapWidth();
      offsetY.value = getOffsetY() + (0, _elements.toPxNum)(props.offsetY);
      isFocus.value = true;
      (0, _components.call)(onFocus);
      validateWithTrigger('onFocus');
      detectBoundary();
    };

    var handleBlur = () => {
      var {
        disabled,
        readonly,
        onBlur
      } = props;

      if (form != null && form.disabled.value || form != null && form.readonly.value || disabled || readonly) {
        return;
      }

      (0, _components.call)(onBlur);
      validateWithTrigger('onBlur');
    };

    var onSelect = option => {
      var {
        disabled,
        readonly,
        multiple,
        onChange
      } = props;

      if (form != null && form.disabled.value || form != null && form.readonly.value || disabled || readonly) {
        return;
      }

      var selectedValue = multiple ? options.filter(_ref4 => {
        var {
          selected
        } = _ref4;
        return selected.value;
      }).map(findValueOrLabel) : findValueOrLabel(option);
      (0, _components.call)(props['onUpdate:modelValue'], selectedValue);
      (0, _components.call)(onChange, selectedValue);
      validateWithTrigger('onChange');
      !multiple && (isFocus.value = false);
    };

    var handleClear = () => {
      var {
        disabled,
        readonly,
        multiple,
        clearable,
        onClear
      } = props;

      if (form != null && form.disabled.value || form != null && form.readonly.value || disabled || readonly || !clearable) {
        return;
      }

      var changedModelValue = multiple ? [] : undefined;
      (0, _components.call)(props['onUpdate:modelValue'], changedModelValue);
      (0, _components.call)(onClear, changedModelValue);
      validateWithTrigger('onClear');
    };

    var handleClick = e => {
      var {
        disabled,
        onClick
      } = props;

      if (form != null && form.disabled.value || disabled) {
        return;
      }

      (0, _components.call)(onClick, e);
      validateWithTrigger('onClick');
    };

    var handleClose = text => {
      var {
        disabled,
        readonly,
        modelValue,
        onClose
      } = props;

      if (form != null && form.disabled.value || form != null && form.readonly.value || disabled || readonly) {
        return;
      }

      var rawModelValue = modelValue;
      var option = options.find(_ref5 => {
        var {
          label
        } = _ref5;
        return label.value === text;
      });
      var currentModelValue = rawModelValue.filter(value => {
        var _value$value;

        return value !== ((_value$value = option.value.value) != null ? _value$value : option.label.value);
      });
      (0, _components.call)(props['onUpdate:modelValue'], currentModelValue);
      (0, _components.call)(onClose, currentModelValue);
      validateWithTrigger('onClose');
    };

    var syncOptions = () => {
      var {
        multiple,
        modelValue
      } = props;

      if (multiple) {
        var rawModelValue = modelValue;
        options.forEach(option => option.sync(rawModelValue.includes(findValueOrLabel(option))));
      } else {
        options.forEach(option => option.sync(modelValue === findValueOrLabel(option)));
      }

      computeLabel();
    }; // expose


    var focus = () => {
      wrapWidth.value = getWrapWidth();
      offsetY.value = getOffsetY() + (0, _elements.toPxNum)(props.offsetY);
      isFocus.value = true;
      detectBoundary();
    }; // expose


    var blur = () => {
      isFocus.value = false;
    }; // expose


    var validate = () => v(props.rules, props.modelValue); // expose


    var reset = () => {
      (0, _components.call)(props['onUpdate:modelValue'], props.multiple ? [] : undefined);
      resetValidation();
    };

    var detectBoundary = () => {
      var {
        body
      } = document;
      var bodyScrollHeight = body.scrollHeight;
      (0, _vue.nextTick)(() => {
        var _menuEl$value;

        var {
          offsetHeight: menuOffsetHeight
        } = (_menuEl$value = menuEl.value) == null ? void 0 : _menuEl$value.parentElement;
        var wrapOffsetTop = (0, _elements.getTop)(wrapEl.value);

        if (wrapOffsetTop + offsetY.value < 0) {
          offsetY.value = getOffsetY();
        }

        if (menuOffsetHeight + wrapOffsetTop + offsetY.value > bodyScrollHeight) {
          offsetY.value -= menuOffsetHeight - getOffsetY();
        }
      });
    };

    (0, _vue.watch)(() => props.multiple, () => {
      var {
        multiple,
        modelValue
      } = props;

      if (multiple && !(0, _shared.isArray)(modelValue)) {
        throw Error('The modelValue must be an array when multiple is true');
      }
    });
    (0, _vue.watch)(() => props.modelValue, syncOptions, {
      deep: true
    });
    (0, _vue.watch)(() => length.value, syncOptions);
    var selectProvider = {
      wrapWidth: (0, _vue.computed)(() => wrapWidth.value),
      multiple,
      focusColor,
      onSelect,
      reset,
      validate,
      resetValidation
    };
    bindOptions(selectProvider);
    (0, _components.call)(bindForm, selectProvider);
    return {
      wrapEl,
      offsetY,
      isFocus,
      errorMessage,
      formDisabled: form == null ? void 0 : form.disabled,
      label,
      labels,
      menuEl,
      n,
      classes,
      computePlaceholderState,
      handleFocus,
      handleBlur,
      handleClear,
      handleClick,
      handleClose,
      reset,
      validate,
      resetValidation,
      focus,
      blur
    };
  }

});

exports.default = _default;