"use strict";

exports.__esModule = true;
exports.default = void 0;

var _vue = require("vue");

var _props = require("./props");

var _elements = require("../utils/elements");

var _zIndex = require("../context/zIndex");

var _components = require("../utils/components");







function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

function _isSlot(s) {
  return typeof s === 'function' || Object.prototype.toString.call(s) === '[object Object]' && !(0, _vue.isVNode)(s);
}

var {
  n,
  classes
} = (0, _components.createNamespace)('menu');

var _default = (0, _vue.defineComponent)({
  name: 'VarMenu',
  props: _props.props,

  setup(props, _ref) {
    var {
      slots
    } = _ref;
    var host = (0, _vue.ref)(null);
    var menu = (0, _vue.ref)(null);
    var to = (0, _vue.ref)();
    var top = (0, _vue.ref)(0);
    var left = (0, _vue.ref)(0);
    var {
      zIndex
    } = (0, _zIndex.useZIndex)(() => props.show, 1);
    var {
      disabled
    } = (0, _components.useTeleport)();
    var clickSelf = false;

    var computeTop = alignment => {
      return alignment === 'top' ? (0, _elements.getTop)(host.value) : (0, _elements.getTop)(host.value) - menu.value.offsetHeight;
    };

    var handleClick = () => {
      clickSelf = true;
    };

    var handleMenuClose = () => {
      if (clickSelf) {
        clickSelf = false;
        return;
      }

      if (!props.show) {
        return;
      }

      (0, _components.call)(props['onUpdate:show'], false);
    }; // expose


    var resize = () => {
      top.value = computeTop(props.alignment);
      left.value = (0, _elements.getLeft)(host.value);
    }; // Transition style use computed place here


    var transitionStyle = (0, _vue.computed)(() => {
      return {
        top: "calc(" + top.value + "px + " + (0, _elements.toSizeUnit)(props.offsetY) + ")",
        left: "calc(" + left.value + "px + " + (0, _elements.toSizeUnit)(props.offsetX) + ")",
        zIndex: zIndex.value
      };
    });

    var renderTransition = () => (0, _vue.createVNode)(_vue.Transition, {
      "name": n(),
      "onAfterEnter": props.onOpened,
      "onAfterLeave": props.onClosed
    }, {
      default: () => [(0, _vue.withDirectives)((0, _vue.createVNode)("div", {
        "class": classes(n('menu'), 'var-elevation--3'),
        "ref": menu,
        "style": transitionStyle.value,
        "onClick": event => {
          event.stopPropagation();
        }
      }, [(0, _components.call)(slots.menu)]), [[_vue.vShow, props.show]])]
    });

    (0, _vue.watch)(() => props.alignment, resize);
    (0, _vue.watch)(() => props.show, /*#__PURE__*/function () {
      var _ref2 = _asyncToGenerator(function* (newValue) {
        var {
          onOpen,
          onClose
        } = props;

        if (newValue) {
          yield (0, _vue.nextTick)();
          resize();
        }

        newValue ? (0, _components.call)(onOpen) : (0, _components.call)(onClose);
      });

      return function (_x) {
        return _ref2.apply(this, arguments);
      };
    }());
    (0, _vue.watch)(() => props.teleport, newValue => {
      to.value = newValue;
    });
    (0, _vue.onMounted)(() => {
      // Synchronously transfer the state to the mount hook to support server-side rendering to prevent hydration errors
      to.value = props.teleport;
      resize();
      document.addEventListener('click', handleMenuClose);
      window.addEventListener('resize', resize);
    });
    (0, _vue.onUnmounted)(() => {
      document.removeEventListener('click', handleMenuClose);
      window.removeEventListener('resize', resize);
    });
    (0, _components.exposeApis)({
      resize
    });
    return () => {
      var _slot;

      return (0, _vue.createVNode)("div", {
        "class": n(),
        "ref": host,
        "onClick": handleClick
      }, [(0, _components.call)(slots.default), to.value ? (0, _vue.createVNode)(_vue.Teleport, {
        "to": to.value,
        "disabled": disabled.value
      }, _isSlot(_slot = renderTransition()) ? _slot : {
        default: () => [_slot]
      }) : renderTransition()]);
    };
  }

});

exports.default = _default;