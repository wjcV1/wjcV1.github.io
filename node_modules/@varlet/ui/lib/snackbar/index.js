"use strict";

exports.__esModule = true;
exports.default = exports._SnackbarComponent = exports.SNACKBAR_TYPE = void 0;

var _vue = require("vue");

var _core = _interopRequireDefault(require("./core.js"));

var _Snackbar = _interopRequireDefault(require("./Snackbar.js"));

var _context = _interopRequireDefault(require("../context"));

var _components = require("../utils/components");

var _shared = require("@varlet/shared");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function _isSlot(s) {
  return typeof s === 'function' || Object.prototype.toString.call(s) === '[object Object]' && !(0, _vue.isVNode)(s);
}

var SNACKBAR_TYPE = ['loading', 'success', 'warning', 'info', 'error'];
exports.SNACKBAR_TYPE = SNACKBAR_TYPE;
var sid = 0;
var isMount = false;
var unmount;
var isAllowMultiple = false;
var uniqSnackbarOptions = (0, _vue.reactive)([]);
var defaultOption = {
  type: undefined,
  content: '',
  position: 'top',
  duration: 3000,
  vertical: false,
  contentClass: undefined,
  loadingType: 'circle',
  loadingSize: 'normal',
  lockScroll: false,
  teleport: 'body',
  forbidClick: false,
  onOpen: () => {},
  onOpened: () => {},
  onClose: () => {},
  onClosed: () => {}
};
var transitionGroupProps = {
  name: 'var-snackbar-fade',
  tag: 'div',
  class: 'var-transition-group'
};
var TransitionGroupHost = {
  setup() {
    return () => {
      var snackbarList = uniqSnackbarOptions.map(_ref => {
        var {
          id,
          reactiveSnackOptions,
          _update
        } = _ref;
        var transitionGroupEl = document.querySelector('.var-transition-group');

        if (reactiveSnackOptions.forbidClick || reactiveSnackOptions.type === 'loading') {
          ;
          transitionGroupEl.classList.add('var-pointer-auto');
        } else {
          ;
          transitionGroupEl.classList.remove('var-pointer-auto');
        }

        if (isAllowMultiple) reactiveSnackOptions.position = 'top';
        var position = isAllowMultiple ? 'relative' : 'absolute'; // avoid stylelint value-keyword-case error

        var style = _extends({
          position
        }, getTop(reactiveSnackOptions.position));

        return (0, _vue.createVNode)(_core.default, (0, _vue.mergeProps)(reactiveSnackOptions, {
          "key": id,
          "style": style,
          "data-id": id,
          "_update": _update,
          'show': reactiveSnackOptions.show,
          "onUpdate:show": $event => reactiveSnackOptions.show = $event
        }), null);
      });
      var zindex = _context.default.zIndex; // avoid stylelint value-keyword-case error

      return (0, _vue.createVNode)(_vue.TransitionGroup, (0, _vue.mergeProps)(transitionGroupProps, {
        "style": {
          zIndex: zindex
        },
        "onAfterEnter": opened,
        "onAfterLeave": removeUniqOption
      }), _isSlot(snackbarList) ? snackbarList : {
        default: () => [snackbarList]
      });
    };
  }

};

var Snackbar = function (options) {
  var snackOptions = (0, _shared.isString)(options) || (0, _shared.isNumber)(options) ? {
    content: String(options)
  } : options;
  var reactiveSnackOptions = (0, _vue.reactive)(_extends({}, defaultOption, snackOptions));
  reactiveSnackOptions.show = true;

  if (!isMount) {
    isMount = true;
    unmount = (0, _components.mountInstance)(TransitionGroupHost).unmountInstance;
  }

  var {
    length
  } = uniqSnackbarOptions;
  var uniqSnackbarOptionItem = {
    id: sid++,
    reactiveSnackOptions
  };

  if (length === 0 || isAllowMultiple) {
    addUniqOption(uniqSnackbarOptionItem);
  } else {
    var _update = "update-" + sid;

    updateUniqOption(reactiveSnackOptions, _update);
  }

  return {
    clear() {
      if (!isAllowMultiple && uniqSnackbarOptions.length) {
        uniqSnackbarOptions[0].reactiveSnackOptions.show = false;
      } else {
        reactiveSnackOptions.show = false;
      }
    }

  };
};

SNACKBAR_TYPE.forEach(type => {
  Snackbar[type] = options => {
    if ((0, _shared.isPlainObject)(options)) {
      options.type = type;
    } else {
      options = {
        content: options,
        type
      };
    }

    return Snackbar(options);
  };
});

Snackbar.install = function (app) {
  app.component(_Snackbar.default.name, _Snackbar.default);
};

Snackbar.allowMultiple = function (bool) {
  if (bool === void 0) {
    bool = false;
  }

  if (bool !== isAllowMultiple) {
    uniqSnackbarOptions.forEach(option => {
      option.reactiveSnackOptions.show = false;
    });
    isAllowMultiple = bool;
  }
};

Snackbar.clear = function () {
  uniqSnackbarOptions.forEach(option => {
    option.reactiveSnackOptions.show = false;
  });
};

Snackbar.Component = _Snackbar.default;

function opened(element) {
  var id = element.getAttribute('data-id');
  var option = uniqSnackbarOptions.find(option => option.id === (0, _shared.toNumber)(id));
  if (option) option.reactiveSnackOptions.onOpened == null ? void 0 : option.reactiveSnackOptions.onOpened();
}

function removeUniqOption(element) {
  element.parentElement && element.parentElement.classList.remove('var-pointer-auto');
  var id = element.getAttribute('data-id');
  var option = uniqSnackbarOptions.find(option => option.id === (0, _shared.toNumber)(id));

  if (option) {
    option.animationEnd = true;
    option.reactiveSnackOptions.onClosed == null ? void 0 : option.reactiveSnackOptions.onClosed();
  }

  var isAllAnimationEnd = uniqSnackbarOptions.every(option => option.animationEnd);

  if (isAllAnimationEnd) {
    unmount == null ? void 0 : unmount();
    uniqSnackbarOptions = (0, _vue.reactive)([]);
    isMount = false;
  }
}

function addUniqOption(uniqSnackbarOptionItem) {
  uniqSnackbarOptions.push(uniqSnackbarOptionItem);
}

function updateUniqOption(reactiveSnackOptions, _update) {
  var [firstOption] = uniqSnackbarOptions;
  firstOption.reactiveSnackOptions = _extends({}, firstOption.reactiveSnackOptions, reactiveSnackOptions);
  firstOption._update = _update;
}

function getTop(position) {
  if (position === void 0) {
    position = 'top';
  }

  if (position === 'bottom') return {
    [position]: '5%'
  };
  return {
    top: position === 'top' ? '5%' : '45%'
  };
}

_Snackbar.default.install = function (app) {
  app.component(_Snackbar.default.name, _Snackbar.default);
};

var _SnackbarComponent = _Snackbar.default;
exports._SnackbarComponent = _SnackbarComponent;
var _default = Snackbar;
exports.default = _default;