"use strict";

exports.__esModule = true;
exports.default = void 0;
exports.render = render;

var _sticky = _interopRequireDefault(require("../sticky"));

var _vue = require("vue");

var _props = require("./props");

var _provide = require("./provide");

var _shared = require("@varlet/shared");

var _shared2 = require("../utils/shared");

var _elements = require("../utils/elements");

var _components = require("../utils/components");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

var {
  n,
  classes
} = (0, _components.createNamespace)('tabs');

function render(_ctx, _cache) {
  return (0, _vue.openBlock)(), (0, _vue.createBlock)((0, _vue.resolveDynamicComponent)(_ctx.sticky ? 'var-sticky' : _ctx.Transition), {
    "offset-top": _ctx.sticky ? _ctx.offsetTop : null
  }, {
    default: (0, _vue.withCtx)(() => [(0, _vue.createElementVNode)("div", (0, _vue.mergeProps)({
      class: _ctx.classes(_ctx.n(), 'var--box', _ctx.n("--item-" + _ctx.itemDirection), _ctx.n("--layout-" + _ctx.layoutDirection + "-padding"), [_ctx.elevation, 'var-elevation--4'], [_ctx.fixedBottom, _ctx.n('--fixed-bottom')], [_ctx.safeArea, _ctx.n('--safe-area')]),
      style: {
        background: _ctx.color
      }
    }, _ctx.$attrs), [(0, _vue.createElementVNode)("div", {
      ref: "scrollerEl",
      class: (0, _vue.normalizeClass)(_ctx.classes(_ctx.n('tab-wrap'), [_ctx.scrollable, _ctx.n("--layout-" + _ctx.layoutDirection + "-scrollable")], _ctx.n("--layout-" + _ctx.layoutDirection)))
    }, [(0, _vue.renderSlot)(_ctx.$slots, "default"), (0, _vue.createElementVNode)("div", {
      class: (0, _vue.normalizeClass)(_ctx.classes(_ctx.n('indicator'), _ctx.n("--layout-" + _ctx.layoutDirection + "-indicator"))),
      style: (0, _vue.normalizeStyle)({
        width: _ctx.layoutDirection === 'horizontal' ? _ctx.indicatorWidth : _ctx.toSizeUnit(_ctx.indicatorSize),
        height: _ctx.layoutDirection === 'horizontal' ? _ctx.toSizeUnit(_ctx.indicatorSize) : _ctx.indicatorHeight,
        transform: _ctx.layoutDirection === 'horizontal' ? "translateX(" + _ctx.indicatorX + ")" : "translateY(" + _ctx.indicatorY + ")",
        background: _ctx.indicatorColor || _ctx.activeColor
      })
    }, null, 6
    /* CLASS, STYLE */
    )], 2
    /* CLASS */
    )], 16
    /* FULL_PROPS */
    )]),
    _: 3
    /* FORWARDED */

  }, 8
  /* PROPS */
  , ["offset-top"]);
}

var _default = (0, _vue.defineComponent)({
  render,
  name: 'VarTabs',
  components: {
    VarSticky: _sticky.default
  },
  inheritAttrs: false,
  props: _props.props,

  setup(props) {
    var indicatorWidth = (0, _vue.ref)('0px');
    var indicatorHeight = (0, _vue.ref)('0px');
    var indicatorX = (0, _vue.ref)('0px');
    var indicatorY = (0, _vue.ref)('0px');
    var scrollable = (0, _vue.ref)(false);
    var scrollerEl = (0, _vue.ref)(null);
    var active = (0, _vue.computed)(() => props.active);
    var activeColor = (0, _vue.computed)(() => props.activeColor);
    var inactiveColor = (0, _vue.computed)(() => props.inactiveColor);
    var disabledColor = (0, _vue.computed)(() => props.disabledColor);
    var itemDirection = (0, _vue.computed)(() => props.itemDirection);
    var {
      tabList,
      bindTabList,
      length
    } = (0, _provide.useTabList)();

    var onTabClick = tab => {
      var _tab$name$value;

      var currentActive = (_tab$name$value = tab.name.value) != null ? _tab$name$value : tab.index.value;
      var {
        active,
        onChange,
        onClick
      } = props;
      (0, _components.call)(props['onUpdate:active'], currentActive);
      (0, _components.call)(onClick, currentActive);
      currentActive !== active && (0, _components.call)(onChange, currentActive);
    };

    var matchName = () => {
      return tabList.find(_ref => {
        var {
          name
        } = _ref;
        return props.active === name.value;
      });
    };

    var matchIndex = activeIndex => {
      return tabList.find(_ref2 => {
        var {
          index
        } = _ref2;
        return (activeIndex != null ? activeIndex : props.active) === index.value;
      });
    };

    var matchBoundary = () => {
      if (length.value === 0) {
        return;
      }

      var {
        active
      } = props;

      if ((0, _shared.isNumber)(active)) {
        var activeIndex = active > length.value - 1 ? length.value - 1 : 0;
        (0, _components.call)(props['onUpdate:active'], activeIndex);
        return matchIndex(activeIndex);
      }
    };

    var watchScrollable = () => {
      scrollable.value = tabList.length >= 5;
    };

    var moveIndicator = _ref3 => {
      var {
        element
      } = _ref3;
      var el = element.value;

      if (props.layoutDirection === 'horizontal') {
        indicatorWidth.value = (el == null ? void 0 : el.offsetWidth) + "px";
        indicatorX.value = (el == null ? void 0 : el.offsetLeft) + "px";
      } else {
        indicatorHeight.value = (el == null ? void 0 : el.offsetHeight) + "px";
        indicatorY.value = (el == null ? void 0 : el.offsetTop) + "px";
      }
    };

    var scrollToCenter = _ref4 => {
      var {
        element
      } = _ref4;

      if (!scrollable.value) {
        return;
      }

      var scroller = scrollerEl.value;
      var el = element.value;

      if (props.layoutDirection === 'horizontal') {
        var left = el.offsetLeft + el.offsetWidth / 2 - scroller.offsetWidth / 2;
        (0, _elements.scrollTo)(scroller, {
          left,
          animation: _shared2.linear
        });
      } else {
        var top = el.offsetTop + el.offsetHeight / 2 - scroller.offsetHeight / 2;
        (0, _elements.scrollTo)(scroller, {
          top,
          animation: _shared2.linear
        });
      }
    }; // expose


    var resize = () => {
      var tab = matchName() || matchIndex() || matchBoundary();

      if (!tab || tab.disabled.value) {
        return;
      }

      watchScrollable();
      moveIndicator(tab);
      scrollToCenter(tab);
    };

    var tabsProvider = {
      active,
      activeColor,
      inactiveColor,
      disabledColor,
      itemDirection,
      resize,
      onTabClick
    };
    bindTabList(tabsProvider);
    (0, _vue.watch)(() => length.value, /*#__PURE__*/_asyncToGenerator(function* () {
      yield (0, _elements.doubleRaf)();
      resize();
    }));
    (0, _vue.watch)(() => props.active, resize);
    (0, _vue.onMounted)(() => window.addEventListener('resize', resize));
    (0, _vue.onUnmounted)(() => window.removeEventListener('resize', resize));
    return {
      indicatorWidth,
      indicatorHeight,
      indicatorX,
      indicatorY,
      scrollable,
      scrollerEl,
      Transition: _vue.Transition,
      toSizeUnit: _elements.toSizeUnit,
      n,
      classes,
      resize
    };
  }

});

exports.default = _default;