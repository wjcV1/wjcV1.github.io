"use strict";

exports.__esModule = true;
exports.default = void 0;
exports.render = render;

var _vue = require("vue");

var _props = require("./props");

var _elements = require("../utils/elements");

var _shared = require("@varlet/shared");

var _components = require("../utils/components");

var {
  n
} = (0, _components.createNamespace)('countdown');
var SECOND = 1000;
var MINUTE = 60 * SECOND;
var HOUR = 60 * MINUTE;
var DAY = 24 * HOUR;

function render(_ctx, _cache) {
  return (0, _vue.openBlock)(), (0, _vue.createElementBlock)("div", {
    class: (0, _vue.normalizeClass)(_ctx.n())
  }, [(0, _vue.renderSlot)(_ctx.$slots, "default", (0, _vue.normalizeProps)((0, _vue.guardReactiveProps)(_ctx.timeData)), () => [(0, _vue.createTextVNode)((0, _vue.toDisplayString)(_ctx.showTime), 1
  /* TEXT */
  )])], 2
  /* CLASS */
  );
}

var _default = (0, _vue.defineComponent)({
  render,
  name: 'VarCountdown',
  props: _props.props,

  setup(props) {
    var endTime = (0, _vue.ref)(0);
    var isStart = (0, _vue.ref)(false);
    var showTime = (0, _vue.ref)('');
    var handle = (0, _vue.ref)(0);
    var pauseTime = (0, _vue.ref)(0);
    var timeData = (0, _vue.ref)({
      days: 0,
      hours: 0,
      minutes: 0,
      seconds: 0,
      milliseconds: 0
    });

    var parseFormat = (format, time) => {
      var scannedTimes = Object.values(time);
      var scannedFormats = ['DD', 'HH', 'mm', 'ss'];
      var padValues = [24, 60, 60, 1000];
      scannedFormats.forEach((scannedFormat, index) => {
        if (!format.includes(scannedFormat)) {
          scannedTimes[index + 1] += scannedTimes[index] * padValues[index];
        } else {
          format = format.replace(scannedFormat, String(scannedTimes[index]).padStart(2, '0'));
        }
      });

      if (format.includes('S')) {
        var ms = String(scannedTimes[scannedTimes.length - 1]).padStart(3, '0');

        if (format.includes('SSS')) {
          format = format.replace('SSS', ms);
        } else if (format.includes('SS')) {
          format = format.replace('SS', ms.slice(0, 2));
        } else {
          format = format.replace('S', ms.slice(0, 1));
        }
      }

      return format;
    };

    var formatTime = durationTime => {
      var days = Math.floor(durationTime / DAY);
      var hours = Math.floor(durationTime % DAY / HOUR);
      var minutes = Math.floor(durationTime % HOUR / MINUTE);
      var seconds = Math.floor(durationTime % MINUTE / SECOND);
      var milliseconds = Math.floor(durationTime % SECOND);
      var time = {
        days,
        hours,
        minutes,
        seconds,
        milliseconds
      };
      timeData.value = time;
      (0, _components.call)(props.onChange, timeData.value);
      showTime.value = parseFormat(props.format, time);
    };

    var countdown = () => {
      var {
        time,
        onEnd,
        autoStart
      } = props;
      var now = Date.now();
      if (!endTime.value) endTime.value = now + (0, _shared.toNumber)(time);
      var durationTime = endTime.value - now;
      if (durationTime < 0) durationTime = 0;
      pauseTime.value = durationTime;
      formatTime(durationTime);

      if (durationTime === 0) {
        (0, _components.call)(onEnd);
        return;
      }

      if (autoStart || isStart.value) handle.value = (0, _elements.requestAnimationFrame)(countdown);
    }; // expose


    var start = () => {
      if (isStart.value) return;
      isStart.value = true;
      endTime.value = Date.now() + (pauseTime.value || (0, _shared.toNumber)(props.time));
      countdown();
    }; // expose


    var pause = () => {
      isStart.value = false;
    }; // expose


    var reset = () => {
      endTime.value = 0;
      isStart.value = false;
      (0, _elements.cancelAnimationFrame)(handle.value);
      countdown();
    };

    (0, _vue.watch)(() => props.time, () => reset(), {
      immediate: true
    });
    return {
      showTime,
      timeData,
      n,
      start,
      pause,
      reset
    };
  }

});

exports.default = _default;