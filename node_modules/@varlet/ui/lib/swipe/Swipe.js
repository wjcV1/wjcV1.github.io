"use strict";

exports.__esModule = true;
exports.default = void 0;
exports.render = render;

var _vue = require("vue");

var _provide = require("./provide");

var _elements = require("../utils/elements");

var _props = require("./props");

var _shared = require("@varlet/shared");

var _components = require("../utils/components");

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

var SWIPE_DELAY = 250;
var SWIPE_DISTANCE = 20;
var {
  n,
  classes
} = (0, _components.createNamespace)('swipe');

var _withScopeId = n => ((0, _vue.pushScopeId)(""), n = n(), (0, _vue.popScopeId)(), n);

var _hoisted_1 = ["onClick"];

function render(_ctx, _cache) {
  return (0, _vue.openBlock)(), (0, _vue.createElementBlock)("div", {
    class: (0, _vue.normalizeClass)(_ctx.n()),
    ref: "swipeEl"
  }, [(0, _vue.createElementVNode)("div", {
    class: (0, _vue.normalizeClass)(_ctx.classes(_ctx.n('track'), [_ctx.vertical, _ctx.n('--vertical')])),
    style: (0, _vue.normalizeStyle)({
      width: !_ctx.vertical ? _ctx.trackSize + "px" : undefined,
      height: _ctx.vertical ? _ctx.trackSize + "px" : undefined,
      transform: "translate" + (_ctx.vertical ? 'Y' : 'X') + "(" + _ctx.translate + "px)",
      transitionDuration: _ctx.lockDuration ? "0ms" : _ctx.toNumber(_ctx.duration) + "ms"
    }),
    onTouchstart: _cache[0] || (_cache[0] = function () {
      return _ctx.handleTouchstart && _ctx.handleTouchstart(...arguments);
    }),
    onTouchmove: _cache[1] || (_cache[1] = function () {
      return _ctx.handleTouchmove && _ctx.handleTouchmove(...arguments);
    }),
    onTouchend: _cache[2] || (_cache[2] = function () {
      return _ctx.handleTouchend && _ctx.handleTouchend(...arguments);
    })
  }, [(0, _vue.renderSlot)(_ctx.$slots, "default")], 38
  /* CLASS, STYLE, HYDRATE_EVENTS */
  ), (0, _vue.renderSlot)(_ctx.$slots, "indicator", {
    index: _ctx.index,
    length: _ctx.length
  }, () => [_ctx.indicator && _ctx.length ? ((0, _vue.openBlock)(), (0, _vue.createElementBlock)("div", {
    key: 0,
    class: (0, _vue.normalizeClass)(_ctx.classes(_ctx.n('indicators'), [_ctx.vertical, _ctx.n('--indicators-vertical')]))
  }, [((0, _vue.openBlock)(true), (0, _vue.createElementBlock)(_vue.Fragment, null, (0, _vue.renderList)(_ctx.length, (l, idx) => {
    return (0, _vue.openBlock)(), (0, _vue.createElementBlock)("div", {
      class: (0, _vue.normalizeClass)(_ctx.classes(_ctx.n('indicator'), [_ctx.index === idx, _ctx.n('--indicator-active')], [_ctx.vertical, _ctx.n('--indicator-vertical')])),
      style: (0, _vue.normalizeStyle)({
        background: _ctx.indicatorColor
      }),
      key: l,
      onClick: $event => _ctx.to(idx)
    }, null, 14
    /* CLASS, STYLE, PROPS */
    , _hoisted_1);
  }), 128
  /* KEYED_FRAGMENT */
  ))], 2
  /* CLASS */
  )) : (0, _vue.createCommentVNode)("v-if", true)])], 2
  /* CLASS */
  );
}

var _default = (0, _vue.defineComponent)({
  render,
  name: 'VarSwipe',
  props: _props.props,

  setup(props) {
    var swipeEl = (0, _vue.ref)(null);
    var size = (0, _vue.ref)(0);
    var vertical = (0, _vue.computed)(() => props.vertical);
    var trackSize = (0, _vue.ref)(0);
    var translate = (0, _vue.ref)(0);
    var lockDuration = (0, _vue.ref)(false);
    var index = (0, _vue.ref)(0);
    var {
      swipeItems,
      bindSwipeItems,
      length
    } = (0, _provide.useSwipeItems)();
    var touching = false;
    var timer = -1;
    var startX;
    var startY;
    var startTime;
    var prevX;
    var prevY;

    var findSwipeItem = idx => swipeItems.find(_ref => {
      var {
        index
      } = _ref;
      return index.value === idx;
    });

    var dispatchBorrower = () => {
      if (!props.loop) {
        return;
      } // track越左边界


      if (translate.value >= 0) {
        findSwipeItem(length.value - 1).setTranslate(-trackSize.value);
      } // track越右边界


      if (translate.value <= -(trackSize.value - size.value)) {
        findSwipeItem(0).setTranslate(trackSize.value);
      } // track没越界


      if (translate.value > -(trackSize.value - size.value) && translate.value < 0) {
        findSwipeItem(length.value - 1).setTranslate(0);
        findSwipeItem(0).setTranslate(0);
      }
    };

    var getSwipeIndex = targetSwipeIndex => {
      var swipeIndex = (0, _shared.isNumber)(targetSwipeIndex) ? targetSwipeIndex : Math.floor((translate.value - size.value / 2) / -size.value);
      var {
        loop
      } = props;

      if (swipeIndex <= -1) {
        return loop ? -1 : 0;
      }

      if (swipeIndex >= length.value) {
        return loop ? length.value : length.value - 1;
      }

      return swipeIndex;
    };

    var swipeIndexToIndex = swipeIndex => {
      var {
        loop
      } = props;

      if (swipeIndex === -1) {
        return loop ? length.value - 1 : 0;
      }

      if (swipeIndex === length.value) {
        return loop ? 0 : length.value - 1;
      }

      return swipeIndex;
    };

    var boundaryIndex = index => {
      var {
        loop
      } = props;

      if (index < 0) {
        return loop ? length.value - 1 : 0;
      }

      if (index > length.value - 1) {
        return loop ? 0 : length.value - 1;
      }

      return index;
    };

    var fixPosition = fn => {
      var overLeft = translate.value >= size.value;
      var overRight = translate.value <= -trackSize.value;
      var leftTranslate = 0;
      var rightTranslate = -(trackSize.value - size.value);
      lockDuration.value = true; // 检测是否有越界情况 越界修正

      if (overLeft || overRight) {
        lockDuration.value = true;
        translate.value = overRight ? leftTranslate : rightTranslate;
        findSwipeItem(0).setTranslate(0);
        findSwipeItem(length.value - 1).setTranslate(0);
      }

      (0, _elements.nextTickFrame)(() => {
        lockDuration.value = false;
        (0, _components.call)(fn);
      });
    };

    var initialIndex = () => {
      index.value = boundaryIndex((0, _shared.toNumber)(props.initialIndex));
    };

    var startAutoplay = () => {
      var {
        autoplay
      } = props;

      if (!autoplay || length.value <= 1) {
        return;
      }

      stopAutoplay();
      timer = window.setTimeout(() => {
        next();
        startAutoplay();
      }, (0, _shared.toNumber)(autoplay));
    };

    var stopAutoplay = () => {
      timer && clearTimeout(timer);
    };

    var getDirection = (x, y) => {
      if (x > y && x > 10) {
        return 'horizontal';
      }

      if (y > x && y > 10) {
        return 'vertical';
      }
    };

    var handleTouchstart = event => {
      if (length.value <= 1 || !props.touchable) {
        return;
      }

      var {
        clientX,
        clientY
      } = event.touches[0];
      startX = clientX;
      startY = clientY;
      startTime = performance.now();
      touching = true;
      stopAutoplay();
      fixPosition(() => {
        lockDuration.value = true;
      });
    };

    var handleTouchmove = event => {
      var {
        touchable,
        vertical
      } = props;

      if (!touching || !touchable) {
        return;
      }

      var {
        clientX,
        clientY
      } = event.touches[0];
      var deltaX = Math.abs(clientX - startX);
      var deltaY = Math.abs(clientY - startY);
      var direction = getDirection(deltaX, deltaY);
      var expectDirection = vertical ? 'vertical' : 'horizontal';

      if (direction === expectDirection) {
        event.preventDefault();
        var moveX = prevX !== undefined ? clientX - prevX : 0;
        var moveY = prevY !== undefined ? clientY - prevY : 0;
        prevX = clientX;
        prevY = clientY;
        translate.value += vertical ? moveY : moveX;
        dispatchBorrower();
      }
    };

    var handleTouchend = () => {
      if (!touching) {
        return;
      }

      var {
        vertical,
        onChange
      } = props;
      var positive = vertical ? prevY < startY : prevX < startX;
      var distance = vertical ? Math.abs(startY - prevY) : Math.abs(startX - prevX);
      var quickSwiping = performance.now() - startTime <= SWIPE_DELAY && distance >= SWIPE_DISTANCE;
      var swipeIndex = quickSwiping ? positive ? getSwipeIndex(index.value + 1) : getSwipeIndex(index.value - 1) : getSwipeIndex();
      touching = false;
      lockDuration.value = false;
      prevX = undefined;
      prevY = undefined;
      translate.value = swipeIndex * -size.value;
      var prevIndex = index.value;
      index.value = swipeIndexToIndex(swipeIndex);
      startAutoplay();
      prevIndex !== index.value && (0, _components.call)(onChange, index.value);
    }; // expose


    var resize = () => {
      lockDuration.value = true;
      size.value = props.vertical ? swipeEl.value.offsetHeight : swipeEl.value.offsetWidth;
      trackSize.value = size.value * length.value;
      translate.value = index.value * -size.value;
      swipeItems.forEach(swipeItem => {
        swipeItem.setTranslate(0);
      });
      startAutoplay();
      setTimeout(() => {
        lockDuration.value = false;
      });
    }; // expose


    var next = () => {
      if (length.value <= 1) {
        return;
      }

      var {
        loop,
        onChange
      } = props;
      var currentIndex = index.value;
      index.value = boundaryIndex(currentIndex + 1);
      (0, _components.call)(onChange, index.value);
      fixPosition(() => {
        if (currentIndex === length.value - 1 && loop) {
          findSwipeItem(0).setTranslate(trackSize.value);
          translate.value = length.value * -size.value;
          return;
        }

        if (currentIndex !== length.value - 1) {
          translate.value = index.value * -size.value;
        }
      });
    }; // expose


    var prev = () => {
      if (length.value <= 1) {
        return;
      }

      var {
        loop,
        onChange
      } = props;
      var currentIndex = index.value;
      index.value = boundaryIndex(currentIndex - 1);
      (0, _components.call)(onChange, index.value);
      fixPosition(() => {
        if (currentIndex === 0 && loop) {
          findSwipeItem(length.value - 1).setTranslate(-trackSize.value);
          translate.value = size.value;
          return;
        }

        if (currentIndex !== 0) {
          translate.value = index.value * -size.value;
        }
      });
    }; // expose


    var to = idx => {
      if (length.value <= 1 || idx === index.value) {
        return;
      }

      idx = idx < 0 ? 0 : idx;
      idx = idx >= length.value ? length.value : idx;
      var task = idx > index.value ? next : prev;
      Array.from({
        length: Math.abs(idx - index.value)
      }).forEach(task);
    };

    var swipeProvider = {
      size,
      vertical
    };
    bindSwipeItems(swipeProvider);
    (0, _vue.watch)(() => length.value, /*#__PURE__*/_asyncToGenerator(function* () {
      // In nuxt, the size of the swipe cannot got when the route is change, need double raf
      yield (0, _elements.doubleRaf)();
      initialIndex();
      resize();
    }));
    (0, _vue.onMounted)(() => {
      window.addEventListener('resize', resize);
    });
    (0, _vue.onUnmounted)(() => {
      window.removeEventListener('resize', resize);
      stopAutoplay();
    });
    return {
      n,
      classes,
      length,
      index,
      swipeEl,
      trackSize,
      translate,
      lockDuration,
      handleTouchstart,
      handleTouchmove,
      handleTouchend,
      next,
      prev,
      to,
      resize,
      toNumber: _shared.toNumber
    };
  }

});

exports.default = _default;