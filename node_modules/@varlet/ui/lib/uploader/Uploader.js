"use strict";

exports.__esModule = true;
exports.default = void 0;
exports.render = render;

var _formDetails = _interopRequireDefault(require("../form-details"));

var _icon = _interopRequireDefault(require("../icon"));

var _popup = _interopRequireDefault(require("../popup"));

var _imagePreview = _interopRequireDefault(require("../image-preview"));

var _ripple = _interopRequireDefault(require("../ripple"));

var _vue = require("vue");

var _props = require("./props");

var _shared = require("@varlet/shared");

var _shared2 = require("../utils/shared");

var _components = require("../utils/components");

var _provide = require("../form/provide");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

var {
  n,
  classes
} = (0, _components.createNamespace)('uploader');
var fid = 0;

var _withScopeId = n => ((0, _vue.pushScopeId)(""), n = n(), (0, _vue.popScopeId)(), n);

var _hoisted_1 = ["onClick"];
var _hoisted_2 = ["onClick"];
var _hoisted_3 = ["src", "alt"];
var _hoisted_4 = ["multiple", "accept", "capture", "disabled"];
var _hoisted_5 = ["src"];

function render(_ctx, _cache) {
  var _component_var_icon = (0, _vue.resolveComponent)("var-icon");

  var _component_var_form_details = (0, _vue.resolveComponent)("var-form-details");

  var _component_var_popup = (0, _vue.resolveComponent)("var-popup");

  var _directive_ripple = (0, _vue.resolveDirective)("ripple");

  return (0, _vue.openBlock)(), (0, _vue.createElementBlock)("div", {
    class: (0, _vue.normalizeClass)(_ctx.classes(_ctx.n(), 'var--box'))
  }, [(0, _vue.createElementVNode)("div", {
    class: (0, _vue.normalizeClass)(_ctx.n('file-list'))
  }, [((0, _vue.openBlock)(true), (0, _vue.createElementBlock)(_vue.Fragment, null, (0, _vue.renderList)(_ctx.files, f => {
    return (0, _vue.withDirectives)(((0, _vue.openBlock)(), (0, _vue.createElementBlock)("div", {
      class: (0, _vue.normalizeClass)(_ctx.classes(_ctx.n('file'), 'var-elevation--2', [f.state === 'loading', _ctx.n('--loading')])),
      key: f.id,
      onClick: $event => _ctx.preview(f)
    }, [(0, _vue.createElementVNode)("div", {
      class: (0, _vue.normalizeClass)(_ctx.n('file-name'))
    }, (0, _vue.toDisplayString)(f.name || f.url), 3
    /* TEXT, CLASS */
    ), _ctx.removable ? ((0, _vue.openBlock)(), (0, _vue.createElementBlock)("div", {
      key: 0,
      class: (0, _vue.normalizeClass)(_ctx.n('file-close')),
      onClick: (0, _vue.withModifiers)($event => _ctx.handleRemove(f), ["stop"])
    }, [(0, _vue.createVNode)(_component_var_icon, {
      class: (0, _vue.normalizeClass)(_ctx.n('file-close-icon')),
      "var-uploader-cover": "",
      name: "delete"
    }, null, 8
    /* PROPS */
    , ["class"])], 10
    /* CLASS, PROPS */
    , _hoisted_2)) : (0, _vue.createCommentVNode)("v-if", true), f.cover ? ((0, _vue.openBlock)(), (0, _vue.createElementBlock)("img", {
      key: 1,
      class: (0, _vue.normalizeClass)(_ctx.n('file-cover')),
      style: (0, _vue.normalizeStyle)({
        objectFit: f.fit
      }),
      src: f.cover,
      alt: f.name
    }, null, 14
    /* CLASS, STYLE, PROPS */
    , _hoisted_3)) : (0, _vue.createCommentVNode)("v-if", true), (0, _vue.createElementVNode)("div", {
      class: (0, _vue.normalizeClass)(_ctx.classes(_ctx.n('file-indicator'), [f.state === 'success', _ctx.n('--success')], [f.state === 'error', _ctx.n('--error')]))
    }, null, 2
    /* CLASS */
    )], 10
    /* CLASS, PROPS */
    , _hoisted_1)), [[_directive_ripple, {
      disabled: _ctx.disabled || _ctx.formDisabled || _ctx.readonly || _ctx.formReadonly || !_ctx.ripple
    }]]);
  }), 128
  /* KEYED_FRAGMENT */
  )), !_ctx.maxlength || _ctx.modelValue.length < _ctx.maxlength ? (0, _vue.withDirectives)(((0, _vue.openBlock)(), (0, _vue.createElementBlock)("div", {
    key: 0,
    class: (0, _vue.normalizeClass)(_ctx.classes([!_ctx.$slots.default, _ctx.n('action') + " var-elevation--2"], [_ctx.disabled || _ctx.formDisabled, _ctx.n('--disabled')])),
    onClick: _cache[1] || (_cache[1] = function () {
      return _ctx.triggerAction && _ctx.triggerAction(...arguments);
    })
  }, [(0, _vue.createElementVNode)("input", {
    ref: "input",
    class: (0, _vue.normalizeClass)(_ctx.n('action-input')),
    type: "file",
    multiple: _ctx.multiple,
    accept: _ctx.accept,
    capture: _ctx.capture,
    disabled: _ctx.disabled || _ctx.formDisabled || _ctx.readonly || _ctx.formReadonly,
    onChange: _cache[0] || (_cache[0] = function () {
      return _ctx.handleChange && _ctx.handleChange(...arguments);
    })
  }, null, 42
  /* CLASS, PROPS, HYDRATE_EVENTS */
  , _hoisted_4), (0, _vue.renderSlot)(_ctx.$slots, "default", {}, () => [(0, _vue.createVNode)(_component_var_icon, {
    class: (0, _vue.normalizeClass)(_ctx.n('action-icon')),
    "var-uploader-cover": "",
    name: "plus"
  }, null, 8
  /* PROPS */
  , ["class"])])], 2
  /* CLASS */
  )), [[_directive_ripple, {
    disabled: _ctx.disabled || _ctx.formDisabled || _ctx.readonly || _ctx.formReadonly || !_ctx.ripple || _ctx.$slots.default
  }]]) : (0, _vue.createCommentVNode)("v-if", true)], 2
  /* CLASS */
  ), (0, _vue.createVNode)(_component_var_form_details, {
    "error-message": _ctx.errorMessage,
    "maxlength-text": _ctx.maxlengthText
  }, null, 8
  /* PROPS */
  , ["error-message", "maxlength-text"]), (0, _vue.createVNode)(_component_var_popup, {
    class: (0, _vue.normalizeClass)(_ctx.n('preview')),
    "var-uploader-cover": "",
    position: "center",
    show: _ctx.showPreview,
    "onUpdate:show": _cache[2] || (_cache[2] = $event => _ctx.showPreview = $event),
    onClosed: _cache[3] || (_cache[3] = $event => _ctx.currentPreview = null)
  }, {
    default: (0, _vue.withCtx)(() => {
      var _ctx$currentPreview, _ctx$currentPreview2;

      return [_ctx.currentPreview && _ctx.isHTMLSupportVideo((_ctx$currentPreview = _ctx.currentPreview) == null ? void 0 : _ctx$currentPreview.url) ? ((0, _vue.openBlock)(), (0, _vue.createElementBlock)("video", {
        key: 0,
        class: (0, _vue.normalizeClass)(_ctx.n('preview-video')),
        playsinline: "true",
        "webkit-playsinline": "true",
        "x5-playsinline": "true",
        "x5-video-player-type": "h5",
        "x5-video-player-fullscreen": "false",
        controls: "",
        src: (_ctx$currentPreview2 = _ctx.currentPreview) == null ? void 0 : _ctx$currentPreview2.url
      }, null, 10
      /* CLASS, PROPS */
      , _hoisted_5)) : (0, _vue.createCommentVNode)("v-if", true)];
    }),
    _: 1
    /* STABLE */

  }, 8
  /* PROPS */
  , ["class", "show"])], 2
  /* CLASS */
  );
}

var _default = (0, _vue.defineComponent)({
  render,
  name: 'VarUploader',
  directives: {
    Ripple: _ripple.default
  },
  components: {
    VarIcon: _icon.default,
    VarPopup: _popup.default,
    VarFormDetails: _formDetails.default
  },
  props: _props.props,

  setup(props) {
    var input = (0, _vue.ref)(null);
    var showPreview = (0, _vue.ref)(false);
    var currentPreview = (0, _vue.ref)(null);
    var maxlengthText = (0, _vue.computed)(() => {
      var {
        maxlength,
        modelValue: {
          length
        }
      } = props;
      return (0, _shared.isNumber)(maxlength) ? length + " / " + maxlength : '';
    });
    var {
      form,
      bindForm
    } = (0, _provide.useForm)();
    var {
      errorMessage,
      validateWithTrigger: vt,
      validate: v,
      // expose
      resetValidation
    } = (0, _components.useValidation)();
    var files = (0, _vue.computed)(() => {
      var {
        modelValue,
        hideList
      } = props;

      if (hideList) {
        return [];
      }

      return modelValue;
    });

    var triggerAction = () => {
      input.value.click();
    };

    var preview = varFile => {
      var {
        disabled,
        readonly,
        previewed
      } = props;

      if (form != null && form.disabled.value || form != null && form.readonly.value || disabled || readonly || !previewed) {
        return;
      }

      var {
        url
      } = varFile;

      if ((0, _shared.isString)(url) && (0, _shared2.isHTMLSupportImage)(url)) {
        (0, _imagePreview.default)(url);
        return;
      }

      if ((0, _shared.isString)(url) && (0, _shared2.isHTMLSupportVideo)(url)) {
        currentPreview.value = varFile;
        showPreview.value = true;
      }
    };

    var createVarFile = file => {
      return {
        id: fid++,
        url: '',
        cover: '',
        name: file.name,
        file
      };
    };

    var getFiles = event => {
      var el = event.target;
      var {
        files: fileList
      } = el;
      return Array.from(fileList);
    };

    var resolver = varFile => {
      return new Promise(resolve => {
        var fileReader = new FileReader();

        fileReader.onload = () => {
          var base64 = fileReader.result;
          varFile.file.type.startsWith('image') && (varFile.cover = base64);
          varFile.url = base64;
          resolve(varFile);
        };

        fileReader.readAsDataURL(varFile.file);
      });
    };

    var getResolvers = varFiles => varFiles.map(resolver);

    var getBeforeReaders = varFiles => {
      var {
        onBeforeRead
      } = props;
      return varFiles.map(varFile => {
        return new Promise(resolve => {
          var valid = onBeforeRead ? onBeforeRead((0, _vue.reactive)(varFile)) : true;
          Promise.resolve(valid).then(valid => resolve({
            valid,
            varFile
          }));
        });
      });
    };

    var handleChange = /*#__PURE__*/function () {
      var _ref = _asyncToGenerator(function* (event) {
        var {
          maxsize,
          maxlength,
          modelValue,
          onOversize,
          onAfterRead,
          readonly,
          disabled
        } = props;

        if (form != null && form.disabled.value || form != null && form.readonly.value || disabled || readonly) {
          return;
        }

        var getValidSizeVarFile = varFiles => {
          return varFiles.filter(varFile => {
            if (varFile.file.size > (0, _shared.toNumber)(maxsize)) {
              (0, _components.call)(onOversize, (0, _vue.reactive)(varFile));
              return false;
            }

            return true;
          });
        };

        var getValidLengthVarFiles = varFiles => {
          var limit = Math.min(varFiles.length, (0, _shared.toNumber)(maxlength) - modelValue.length);
          return varFiles.slice(0, limit);
        }; // limit


        var files = getFiles(event);
        var varFiles = files.map(createVarFile);
        varFiles = maxsize != null ? getValidSizeVarFile(varFiles) : varFiles;
        varFiles = maxlength != null ? getValidLengthVarFiles(varFiles) : varFiles; // pre resolve

        var resolvedVarFiles = yield Promise.all(getResolvers(varFiles));
        var validationVarFiles = yield Promise.all(getBeforeReaders(resolvedVarFiles));
        var validVarFiles = validationVarFiles.filter(_ref2 => {
          var {
            valid
          } = _ref2;
          return valid;
        }).map(_ref3 => {
          var {
            varFile
          } = _ref3;
          return varFile;
        });
        (0, _components.call)(props['onUpdate:modelValue'], [...modelValue, ...validVarFiles]);
        event.target.value = '';
        validVarFiles.forEach(varFile => (0, _components.call)(onAfterRead, (0, _vue.reactive)(varFile)));
      });

      return function handleChange(_x) {
        return _ref.apply(this, arguments);
      };
    }();

    var handleRemove = /*#__PURE__*/function () {
      var _ref4 = _asyncToGenerator(function* (removedVarFile) {
        var {
          disabled,
          readonly,
          modelValue,
          onBeforeRemove,
          onRemove
        } = props;

        if (form != null && form.disabled.value || form != null && form.readonly.value || disabled || readonly) {
          return;
        }

        if (onBeforeRemove && !(yield onBeforeRemove(removedVarFile))) {
          return;
        }

        var expectedFiles = modelValue.filter(varFile => varFile !== removedVarFile);
        (0, _components.call)(onRemove, removedVarFile);
        validateWithTrigger('onRemove');
        (0, _components.call)(props['onUpdate:modelValue'], expectedFiles);
      });

      return function handleRemove(_x2) {
        return _ref4.apply(this, arguments);
      };
    }(); // expose


    var getSuccess = () => props.modelValue.filter(varFile => varFile.state === 'success'); // expose


    var getError = () => props.modelValue.filter(varFile => varFile.state === 'error'); // expose


    var getLoading = () => props.modelValue.filter(varFile => varFile.state === 'loading');

    var varFileUtils = {
      getSuccess,
      getError,
      getLoading
    };

    var validateWithTrigger = trigger => {
      (0, _vue.nextTick)(() => {
        var {
          validateTrigger,
          rules,
          modelValue
        } = props;
        vt(validateTrigger, trigger, rules, modelValue, varFileUtils);
      });
    };

    var callReset = false; // expose

    var validate = () => v(props.rules, props.modelValue, varFileUtils); // expose


    var reset = () => {
      callReset = true;
      (0, _components.call)(props['onUpdate:modelValue'], []);
      resetValidation();
    };

    var uploaderProvider = {
      validate,
      resetValidation,
      reset
    };
    (0, _components.call)(bindForm, uploaderProvider);
    (0, _vue.watch)(() => props.modelValue, () => {
      !callReset && validateWithTrigger('onChange');
      callReset = false;
    }, {
      deep: true
    });
    return {
      n,
      classes,
      input,
      files,
      showPreview,
      currentPreview,
      errorMessage,
      maxlengthText,
      isHTMLSupportVideo: _shared2.isHTMLSupportVideo,
      isHTMLSupportImage: _shared2.isHTMLSupportImage,
      formDisabled: form == null ? void 0 : form.disabled,
      formReadonly: form == null ? void 0 : form.readonly,
      preview,
      triggerAction,
      handleChange,
      handleRemove,
      getSuccess,
      getError,
      getLoading,
      validate,
      resetValidation,
      reset
    };
  }

});

exports.default = _default;