"use strict";

exports.__esModule = true;
exports.default = void 0;
exports.render = render;

var _loading = _interopRequireDefault(require("../loading"));

var _ripple = _interopRequireDefault(require("../ripple"));

var _vue = require("vue");

var _elements = require("../utils/elements");

var _props = require("./props");

var _shared = require("@varlet/shared");

var _shared2 = require("../utils/shared");

var _components = require("../utils/components");

var _locale = require("../locale");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

var {
  n,
  classes
} = (0, _components.createNamespace)('list');

function render(_ctx, _cache) {
  var _component_var_loading = (0, _vue.resolveComponent)("var-loading");

  var _directive_ripple = (0, _vue.resolveDirective)("ripple");

  return (0, _vue.openBlock)(), (0, _vue.createElementBlock)("div", {
    class: (0, _vue.normalizeClass)(_ctx.classes(_ctx.n(), 'var--box')),
    ref: "listEl"
  }, [(0, _vue.renderSlot)(_ctx.$slots, "default"), _ctx.loading ? (0, _vue.renderSlot)(_ctx.$slots, "loading", {
    key: 0
  }, () => [(0, _vue.createElementVNode)("div", {
    class: (0, _vue.normalizeClass)(_ctx.n('loading'))
  }, [(0, _vue.createElementVNode)("div", {
    class: (0, _vue.normalizeClass)(_ctx.n('loading-text'))
  }, (0, _vue.toDisplayString)(_ctx.dt(_ctx.loadingText, _ctx.pack.listLoadingText)), 3
  /* TEXT, CLASS */
  ), (0, _vue.createVNode)(_component_var_loading, {
    size: "mini",
    radius: 10
  })], 2
  /* CLASS */
  )]) : (0, _vue.createCommentVNode)("v-if", true), _ctx.finished ? (0, _vue.renderSlot)(_ctx.$slots, "finished", {
    key: 1
  }, () => [(0, _vue.createElementVNode)("div", {
    class: (0, _vue.normalizeClass)(_ctx.n('finished'))
  }, (0, _vue.toDisplayString)(_ctx.dt(_ctx.finishedText, _ctx.pack.listFinishedText)), 3
  /* TEXT, CLASS */
  )]) : (0, _vue.createCommentVNode)("v-if", true), _ctx.error ? (0, _vue.renderSlot)(_ctx.$slots, "error", {
    key: 2
  }, () => [(0, _vue.withDirectives)(((0, _vue.openBlock)(), (0, _vue.createElementBlock)("div", {
    class: (0, _vue.normalizeClass)(_ctx.n('error')),
    onClick: _cache[0] || (_cache[0] = function () {
      return _ctx.load && _ctx.load(...arguments);
    })
  }, [(0, _vue.createTextVNode)((0, _vue.toDisplayString)(_ctx.dt(_ctx.errorText, _ctx.pack.listErrorText)), 1
  /* TEXT */
  )], 2
  /* CLASS */
  )), [[_directive_ripple]])]) : (0, _vue.createCommentVNode)("v-if", true), (0, _vue.createElementVNode)("div", {
    class: (0, _vue.normalizeClass)(_ctx.n('detector')),
    ref: "detectorEl"
  }, null, 2
  /* CLASS */
  )], 2
  /* CLASS */
  );
}

var _default = (0, _vue.defineComponent)({
  render,
  name: 'VarList',
  directives: {
    Ripple: _ripple.default
  },
  components: {
    VarLoading: _loading.default
  },
  props: _props.props,

  setup(props) {
    var listEl = (0, _vue.ref)(null);
    var detectorEl = (0, _vue.ref)(null);
    var scroller;

    var load = () => {
      (0, _components.call)(props['onUpdate:error'], false);
      (0, _components.call)(props['onUpdate:loading'], true);
      (0, _components.call)(props.onLoad);
    };

    var isReachBottom = () => {
      var containerBottom = scroller === window ? window.innerHeight : scroller.getBoundingClientRect().bottom;
      var {
        bottom: detectorBottom
      } = detectorEl.value.getBoundingClientRect(); // The fractional part of the detectorBottom when bottoming out overflows
      // https://github.com/varletjs/varlet/issues/310

      return Math.floor(detectorBottom) - (0, _elements.toPxNum)(props.offset) <= containerBottom;
    }; // expose


    var check = /*#__PURE__*/function () {
      var _ref = _asyncToGenerator(function* () {
        yield (0, _vue.nextTick)();
        var {
          loading,
          finished,
          error
        } = props;

        if (!loading && !finished && !error && isReachBottom()) {
          load();
        }
      });

      return function check() {
        return _ref.apply(this, arguments);
      };
    }();

    (0, _vue.onMounted)(() => {
      scroller = (0, _elements.getParentScroller)(listEl.value);
      props.immediateCheck && check();
      scroller.addEventListener('scroll', check);
    });
    (0, _vue.onUnmounted)(() => {
      scroller.removeEventListener('scroll', check);
    });
    return {
      pack: _locale.pack,
      listEl,
      detectorEl,
      dt: _shared2.dt,
      isNumber: _shared.isNumber,
      load,
      check,
      n,
      classes
    };
  }

});

exports.default = _default;