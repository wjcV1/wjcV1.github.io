"use strict";

exports.__esModule = true;
exports.default = void 0;
exports.render = render;

var _icon = _interopRequireDefault(require("../icon"));

var _vue = require("vue");

var _elements = require("../utils/elements");

var _props = require("./props");

var _shared = require("@varlet/shared");

var _components = require("../utils/components");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

var {
  n,
  classes
} = (0, _components.createNamespace)('pull-refresh');
var MAX_DISTANCE = 100;
var CONTROL_POSITION = -50;
var ICON_TRANSITION = 150;

function render(_ctx, _cache) {
  var _component_var_icon = (0, _vue.resolveComponent)("var-icon");

  return (0, _vue.openBlock)(), (0, _vue.createElementBlock)("div", {
    ref: "freshNode",
    class: (0, _vue.normalizeClass)(_ctx.n()),
    onTouchstart: _cache[0] || (_cache[0] = function () {
      return _ctx.touchStart && _ctx.touchStart(...arguments);
    }),
    onTouchmove: _cache[1] || (_cache[1] = function () {
      return _ctx.touchMove && _ctx.touchMove(...arguments);
    }),
    onTouchend: _cache[2] || (_cache[2] = function () {
      return _ctx.touchEnd && _ctx.touchEnd(...arguments);
    }),
    onTouchcancel: _cache[3] || (_cache[3] = function () {
      return _ctx.touchEnd && _ctx.touchEnd(...arguments);
    })
  }, [(0, _vue.createElementVNode)("div", {
    class: (0, _vue.normalizeClass)(_ctx.classes(_ctx.n('control'), 'var-elevation--2', [_ctx.isSuccess, _ctx.n('control-success')])),
    style: (0, _vue.normalizeStyle)(_ctx.controlStyle)
  }, [(0, _vue.createVNode)(_component_var_icon, {
    name: _ctx.iconName,
    transition: _ctx.ICON_TRANSITION,
    class: (0, _vue.normalizeClass)(_ctx.classes(_ctx.n('icon'), [_ctx.refreshStatus === 'loading' && _ctx.iconHasChanged, _ctx.n('animation')])),
    "var-pull-refresh-cover": ""
  }, null, 8
  /* PROPS */
  , ["name", "transition", "class"])], 6
  /* CLASS, STYLE */
  ), (0, _vue.renderSlot)(_ctx.$slots, "default")], 34
  /* CLASS, HYDRATE_EVENTS */
  );
}

var _default = (0, _vue.defineComponent)({
  render,
  name: 'VarPullRefresh',
  components: {
    VarIcon: _icon.default
  },
  props: _props.props,

  setup(props) {
    var scroller;
    var changing;
    var freshNode = (0, _vue.ref)(null);
    var startPosition = (0, _vue.ref)(0);
    var distance = (0, _vue.ref)(CONTROL_POSITION);
    var iconName = (0, _vue.ref)('arrow-down');
    var refreshStatus = (0, _vue.ref)('default');
    var isEnd = (0, _vue.ref)(false); // https://github.com/varletjs/varlet/issues/509

    var iconHasChanged = (0, _vue.ref)(true);
    var isTouchable = (0, _vue.computed)(() => refreshStatus.value !== 'loading' && refreshStatus.value !== 'success' && !props.disabled);
    var controlStyle = (0, _vue.computed)(() => ({
      transform: "translate3d(0px, " + distance.value + "px, 0px) translate(-50%, 0)",
      transition: isEnd.value ? "transform " + props.animationDuration + "ms" : undefined,
      background: isSuccess.value ? props.successBgColor : props.bgColor,
      color: isSuccess.value ? props.successColor : props.color
    }));
    var isSuccess = (0, _vue.computed)(() => refreshStatus.value === 'success');

    var changeIcon = () => {
      return new Promise(resolve => {
        window.setTimeout(() => {
          iconHasChanged.value = true;
          resolve();
        }, ICON_TRANSITION);
      });
    };

    var touchStart = event => {
      if (!isTouchable.value) return;
      refreshStatus.value = 'pulling';
      startPosition.value = event.touches[0].clientY;
    };

    var touchMove = event => {
      var scrollTop = (0, _elements.getScrollTop)(scroller);
      if (scrollTop > 0 || !isTouchable.value) return;
      if (scrollTop === 0 && distance.value > CONTROL_POSITION) event.cancelable && event.preventDefault();
      var moveDistance = (event.touches[0].clientY - startPosition.value) / 2 + CONTROL_POSITION;
      distance.value = moveDistance >= MAX_DISTANCE ? MAX_DISTANCE : moveDistance;

      if (distance.value >= MAX_DISTANCE * 0.2) {
        iconHasChanged.value = false;
        iconName.value = 'refresh';
        changing = changeIcon();
      } else {
        iconName.value = 'arrow-down';
      }
    };

    var touchEnd = /*#__PURE__*/function () {
      var _ref = _asyncToGenerator(function* () {
        if (!isTouchable.value) return;
        isEnd.value = true;

        if (distance.value >= MAX_DISTANCE * 0.2) {
          var _props$onUpdateModel;

          yield changing;
          refreshStatus.value = 'loading';
          distance.value = MAX_DISTANCE * 0.3;
          (_props$onUpdateModel = props['onUpdate:modelValue']) == null ? void 0 : _props$onUpdateModel.call(props, true);
          props.onRefresh == null ? void 0 : props.onRefresh();
        } else {
          refreshStatus.value = 'loosing';
          iconName.value = 'arrow-down';
          distance.value = CONTROL_POSITION;
          setTimeout(() => {
            isEnd.value = false;
          }, (0, _shared.toNumber)(props.animationDuration));
        }
      });

      return function touchEnd() {
        return _ref.apply(this, arguments);
      };
    }();

    var reset = () => {
      setTimeout(() => {
        refreshStatus.value = 'default';
        iconName.value = 'arrow-down';
        isEnd.value = false;
      }, (0, _shared.toNumber)(props.animationDuration));
    };

    (0, _vue.watch)(() => props.modelValue, newValue => {
      if (newValue === false) {
        isEnd.value = true;
        refreshStatus.value = 'success';
        iconName.value = 'checkbox-marked-circle';
        setTimeout(() => {
          distance.value = CONTROL_POSITION;
          reset();
        }, (0, _shared.toNumber)(props.successDuration));
      }
    });
    (0, _vue.onMounted)(() => {
      scroller = (0, _elements.getParentScroller)(freshNode.value);
    });
    return {
      n,
      classes,
      iconHasChanged,
      ICON_TRANSITION,
      refreshStatus,
      freshNode,
      touchStart,
      touchMove,
      touchEnd,
      iconName,
      controlStyle,
      isSuccess
    };
  }

});

exports.default = _default;