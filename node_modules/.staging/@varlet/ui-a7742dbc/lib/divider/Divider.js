"use strict";

exports.__esModule = true;
exports.default = void 0;
exports.render = render;

var _vue = require("vue");

var _elements = require("../utils/elements");

var _shared = require("@varlet/shared");

var _props = require("./props");

var _components = require("../utils/components");

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

var {
  n,
  classes
} = (0, _components.createNamespace)('divider');

function render(_ctx, _cache) {
  return (0, _vue.openBlock)(), (0, _vue.createElementBlock)("div", {
    class: (0, _vue.normalizeClass)(_ctx.classes(_ctx.n(), 'var--box', [_ctx.vertical, _ctx.n('--vertical')], [_ctx.withText, _ctx.n('--with-text')], [_ctx.isInset, _ctx.n('--inset')], [_ctx.dashed, _ctx.n('--dashed')])),
    style: (0, _vue.normalizeStyle)(_ctx.style)
  }, [(0, _vue.renderSlot)(_ctx.$slots, "default", {}, () => [_ctx.description ? ((0, _vue.openBlock)(), (0, _vue.createElementBlock)("span", {
    key: 0,
    class: (0, _vue.normalizeClass)(_ctx.n('text'))
  }, (0, _vue.toDisplayString)(_ctx.description), 3
  /* TEXT, CLASS */
  )) : (0, _vue.createCommentVNode)("v-if", true)])], 6
  /* CLASS, STYLE */
  );
}

var _default = (0, _vue.defineComponent)({
  render,
  name: 'VarDivider',
  props: _props.props,

  setup(props, _ref) {
    var {
      slots
    } = _ref;
    var state = (0, _vue.reactive)({
      withText: false
    });
    var isInset = (0, _vue.computed)(() => (0, _shared.isBoolean)(props.inset) ? props.inset : true);
    var style = (0, _vue.computed)(() => {
      var {
        inset,
        vertical,
        margin
      } = props;
      var baseStyle = {
        margin
      };
      if ((0, _shared.isBoolean)(inset) || inset === 0) return _extends({}, baseStyle); // -18px -> -18

      var _inset = (0, _shared.toNumber)(inset); // -18px -> 18px


      var absInsetWithUnit = Math.abs(_inset) + (inset + '').replace(_inset + '', '');
      return vertical ? _extends({}, baseStyle, {
        height: "calc(80% - " + (0, _elements.toSizeUnit)(absInsetWithUnit) + ")"
      }) : _extends({}, baseStyle, {
        width: "calc(100% - " + (0, _elements.toSizeUnit)(absInsetWithUnit) + ")",
        left: _inset > 0 ? (0, _elements.toSizeUnit)(absInsetWithUnit) : (0, _elements.toSizeUnit)(0)
      });
    });

    var checkHasText = () => {
      state.withText = Boolean(slots.default) || Boolean(props.description);
    };

    (0, _vue.onMounted)(() => {
      checkHasText();
    });
    (0, _vue.onUpdated)(() => {
      checkHasText();
    });
    return _extends({
      n,
      classes
    }, (0, _vue.toRefs)(state), {
      style,
      isInset
    });
  }

});

exports.default = _default;