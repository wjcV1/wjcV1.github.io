"use strict";

exports.__esModule = true;
exports.default = void 0;
exports.render = render;

var _vue = require("vue");

var _provide = require("./provide");

var _props = require("./props");

var _components = require("../utils/components");

var _shared = require("@varlet/shared");

var {
  n
} = (0, _components.createNamespace)('collapse');

function render(_ctx, _cache) {
  return (0, _vue.openBlock)(), (0, _vue.createElementBlock)("div", {
    class: (0, _vue.normalizeClass)(_ctx.n())
  }, [(0, _vue.renderSlot)(_ctx.$slots, "default")], 2
  /* CLASS */
  );
}

var _default = (0, _vue.defineComponent)({
  render,
  name: 'VarCollapse',
  props: _props.props,

  setup(props) {
    var {
      length,
      collapseItem,
      bindCollapseItem
    } = (0, _provide.useCollapseItem)();
    var active = (0, _vue.computed)(() => props.modelValue);
    var offset = (0, _vue.computed)(() => props.offset);

    var checkValue = () => {
      if (!props.accordion && !(0, _shared.isArray)(props.modelValue)) {
        console.error('[Varlet] Collapse: type of prop "modelValue" should be an Array');
        return false;
      }

      if (props.accordion && (0, _shared.isArray)(props.modelValue)) {
        console.error('[Varlet] Collapse: type of prop "modelValue" should be a String or Number');
        return false;
      }

      return true;
    };

    var getValue = (value, isExpand) => {
      if (!checkValue()) return null;
      if (isExpand) return props.accordion ? value : [...props.modelValue, value];
      return props.accordion ? null : props.modelValue.filter(name => name !== value);
    };

    var updateItem = (value, isExpand) => {
      var modelValue = getValue(value, isExpand);
      (0, _components.call)(props['onUpdate:modelValue'], modelValue);
      (0, _components.call)(props.onChange, modelValue);
    };

    var matchName = () => {
      if (props.accordion) {
        return collapseItem.find(_ref => {
          var {
            name
          } = _ref;
          return props.modelValue === name.value;
        });
      }

      var filterItem = collapseItem.filter(_ref2 => {
        var {
          name
        } = _ref2;
        if (name.value === undefined) return false;
        return props.modelValue.includes(name.value);
      });
      return filterItem.length ? filterItem : undefined;
    };

    var matchIndex = () => {
      if (props.accordion) {
        return collapseItem.find(_ref3 => {
          var {
            index,
            name
          } = _ref3;
          return name.value === undefined ? props.modelValue === index.value : false;
        });
      }

      return collapseItem.filter(_ref4 => {
        var {
          index,
          name
        } = _ref4;
        return name.value === undefined ? props.modelValue.includes(index.value) : false;
      });
    };

    var resize = () => {
      if (!checkValue()) return;
      var matchProviders = matchName() || matchIndex();

      if (props.accordion && !matchProviders || !props.accordion && !matchProviders.length) {
        collapseItem.forEach(provider => {
          provider.init(props.accordion, false);
        });
        return;
      }

      collapseItem.forEach(provider => {
        var isShow = props.accordion ? matchProviders === provider : matchProviders.includes(provider);
        provider.init(props.accordion, isShow);
      });
    };

    var collapseProvider = {
      active,
      offset,
      updateItem
    };
    bindCollapseItem(collapseProvider);
    (0, _vue.watch)(() => length.value, () => (0, _vue.nextTick)().then(resize));
    (0, _vue.watch)(() => props.modelValue, () => (0, _vue.nextTick)().then(resize));
    return {
      n
    };
  }

});

exports.default = _default;