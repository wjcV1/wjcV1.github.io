var _excluded = ["collect", "clear"];

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

import { createApp, h, getCurrentInstance, inject, onUnmounted, computed, provide, reactive, isVNode, onMounted, onBeforeUnmount, nextTick, ref, onActivated, onDeactivated } from 'vue';
import { isArray, removeItem } from '@varlet/shared';
export function pickProps(props, propsKey) {
  return Array.isArray(propsKey) ? propsKey.reduce((pickedProps, key) => {
    pickedProps[key] = props[key];
    return pickedProps;
  }, {}) : props[propsKey];
}
export function mount(component) {
  var app = createApp(component);
  var host = document.createElement('div');
  document.body.appendChild(host);
  return {
    instance: app.mount(host),

    unmount() {
      app.unmount();
      document.body.removeChild(host);
    }

  };
}
export function mountInstance(component, props, eventListener) {
  if (props === void 0) {
    props = {};
  }

  if (eventListener === void 0) {
    eventListener = {};
  }

  var Host = {
    setup() {
      return () => h(component, _extends({}, props, eventListener));
    }

  };
  var {
    unmount
  } = mount(Host);
  return {
    unmountInstance: unmount
  };
}
export function flatVNodes(subTree) {
  var vNodes = [];

  var flat = subTree => {
    if (subTree != null && subTree.component) {
      flat(subTree == null ? void 0 : subTree.component.subTree);
      return;
    }

    if (Array.isArray(subTree == null ? void 0 : subTree.children)) {
      subTree.children.forEach(child => {
        if (isVNode(child)) {
          vNodes.push(child);
          flat(child);
        }
      });
    }
  };

  flat(subTree);
  return vNodes;
}
export function useAtChildrenCounter(key) {
  var instances = reactive([]);
  var parentInstance = getCurrentInstance();

  var sortInstances = () => {
    var vNodes = flatVNodes(parentInstance.subTree);
    instances.sort((a, b) => {
      return vNodes.indexOf(a.vnode) - vNodes.indexOf(b.vnode);
    });
  };

  var collect = instance => {
    instances.push(instance);
    sortInstances();
  };

  var clear = instance => {
    removeItem(instances, instance);
  };

  provide(key, {
    collect,
    clear,
    instances
  });
  var length = computed(() => instances.length);
  return {
    length
  };
}
export function useAtParentIndex(key) {
  if (!keyInProvides(key)) {
    return {
      index: null
    };
  }

  var childrenCounter = inject(key);
  var {
    collect,
    clear,
    instances
  } = childrenCounter;
  var instance = getCurrentInstance();
  onMounted(() => {
    nextTick().then(() => collect(instance));
  });
  onUnmounted(() => {
    nextTick().then(() => clear(instance));
  });
  var index = computed(() => instances.indexOf(instance));
  return {
    index
  };
}
export function useChildren(key) {
  var childProviders = [];

  var collect = childProvider => {
    childProviders.push(childProvider);
  };

  var clear = childProvider => {
    removeItem(childProviders, childProvider);
  };

  var bindChildren = parentProvider => {
    provide(key, _extends({
      collect,
      clear
    }, parentProvider));
  };

  return {
    childProviders,
    bindChildren
  };
}
export function useParent(key) {
  if (!keyInProvides(key)) {
    return {
      parentProvider: null,
      bindParent: null
    };
  }

  var rawParentProvider = inject(key);

  var {
    collect,
    clear
  } = rawParentProvider,
      parentProvider = _objectWithoutPropertiesLoose(rawParentProvider, _excluded);

  var bindParent = childProvider => {
    onMounted(() => collect(childProvider));
    onBeforeUnmount(() => clear(childProvider));
  };

  return {
    parentProvider,
    bindParent
  };
}
export function keyInProvides(key) {
  var instance = getCurrentInstance();
  return key in instance.provides;
}
export function useValidation() {
  var errorMessage = ref('');

  var validate = /*#__PURE__*/function () {
    var _ref = _asyncToGenerator(function* (rules, value, apis) {
      if (!isArray(rules) || !rules.length) {
        return true;
      }

      var resArr = yield Promise.all(rules.map(rule => rule(value, apis)));
      return !resArr.some(res => {
        if (res !== true) {
          errorMessage.value = String(res);
          return true;
        }

        return false;
      });
    });

    return function validate(_x, _x2, _x3) {
      return _ref.apply(this, arguments);
    };
  }();

  var resetValidation = () => {
    errorMessage.value = '';
  };

  var validateWithTrigger = /*#__PURE__*/function () {
    var _ref2 = _asyncToGenerator(function* (validateTrigger, trigger, rules, value, apis) {
      if (validateTrigger.includes(trigger)) {
        ;
        (yield validate(rules, value, apis)) && (errorMessage.value = '');
      }
    });

    return function validateWithTrigger(_x4, _x5, _x6, _x7, _x8) {
      return _ref2.apply(this, arguments);
    };
  }();

  return {
    errorMessage,
    validate,
    resetValidation,
    validateWithTrigger
  };
}
export function addRouteListener(cb) {
  onMounted(() => {
    window.addEventListener('hashchange', cb);
    window.addEventListener('popstate', cb);
  });
  onUnmounted(() => {
    window.removeEventListener('hashchange', cb);
    window.removeEventListener('popstate', cb);
  });
}
export function useTeleport() {
  var disabled = ref(false);
  onActivated(() => {
    disabled.value = false;
  });
  onDeactivated(() => {
    disabled.value = true;
  });
  return {
    disabled
  };
}
export function exposeApis(apis) {
  var instance = getCurrentInstance();

  if (instance) {
    Object.assign(instance.proxy, apis);
  }
}
export function createNamespace(name) {
  var namespace = "var-" + name;

  var createBEM = suffix => {
    if (!suffix) return namespace;
    return suffix.startsWith('--') ? "" + namespace + suffix : namespace + "__" + suffix;
  };

  var classes = function () {
    for (var _len = arguments.length, classes = new Array(_len), _key = 0; _key < _len; _key++) {
      classes[_key] = arguments[_key];
    }

    return classes.map(className => {
      if (isArray(className)) {
        var [condition, truthy, falsy = null] = className;
        return condition ? truthy : falsy;
      }

      return className;
    });
  };

  return {
    n: createBEM,
    classes
  };
}
export function call(fn) {
  for (var _len2 = arguments.length, arg = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
    arg[_key2 - 1] = arguments[_key2];
  }

  if (fn) return fn(...arg);
}