function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

import { defineComponent, ref, onMounted, computed, reactive, nextTick, watch } from 'vue';
import { useValidation, createNamespace, call } from '../utils/components';
import { useForm } from '../form/provide';
import { getLeft, multiplySizeUnit } from '../utils/elements';
import { isArray, isNumber, toNumber } from '@varlet/shared';
import { props } from './props';
import VarFormDetails from '../form-details';
var {
  n,
  classes
} = createNamespace('slider');
var Thumbs;

(function (Thumbs) {
  Thumbs["First"] = "1";
  Thumbs["Second"] = "2";
})(Thumbs || (Thumbs = {}));

import { normalizeClass as _normalizeClass, normalizeStyle as _normalizeStyle, createElementVNode as _createElementVNode, renderList as _renderList, Fragment as _Fragment, openBlock as _openBlock, createElementBlock as _createElementBlock, renderSlot as _renderSlot, toDisplayString as _toDisplayString, withModifiers as _withModifiers, resolveComponent as _resolveComponent, createVNode as _createVNode, pushScopeId as _pushScopeId, popScopeId as _popScopeId } from "vue";

var _withScopeId = n => (_pushScopeId(""), n = n(), _popScopeId(), n);

var _hoisted_1 = ["onTouchstart", "onTouchmove", "onTouchend", "onTouchcancel"];
export function render(_ctx, _cache) {
  var _component_var_form_details = _resolveComponent("var-form-details");

  return _openBlock(), _createElementBlock("div", {
    class: _normalizeClass(_ctx.n())
  }, [_createElementVNode("div", {
    class: _normalizeClass(_ctx.classes(_ctx.n('block'), [_ctx.isDisabled, _ctx.n('--disabled')], [_ctx.errorMessage, _ctx.n('--error')])),
    style: _normalizeStyle({
      height: _ctx.thumbSize === undefined ? _ctx.thumbSize : _ctx.multiplySizeUnit(_ctx.thumbSize, 3),
      margin: _ctx.thumbSize === undefined ? _ctx.thumbSize : "0 " + _ctx.multiplySizeUnit(_ctx.thumbSize, 0.5)
    }),
    ref: "sliderEl",
    onClick: _cache[0] || (_cache[0] = function () {
      return _ctx.click && _ctx.click(...arguments);
    })
  }, [_createElementVNode("div", {
    class: _normalizeClass(_ctx.n('track'))
  }, [_createElementVNode("div", {
    class: _normalizeClass(_ctx.n('track-background')),
    style: _normalizeStyle({
      background: _ctx.trackColor,
      height: _ctx.multiplySizeUnit(_ctx.trackHeight)
    })
  }, null, 6
  /* CLASS, STYLE */
  ), _createElementVNode("div", {
    class: _normalizeClass(_ctx.n('track-fill')),
    style: _normalizeStyle(_ctx.getFillStyle)
  }, null, 6
  /* CLASS, STYLE */
  )], 2
  /* CLASS */
  ), (_openBlock(true), _createElementBlock(_Fragment, null, _renderList(_ctx.thumbList, item => {
    return _openBlock(), _createElementBlock("div", {
      class: _normalizeClass(_ctx.n('thumb')),
      key: item.enumValue,
      style: _normalizeStyle({
        left: item.value + "%",
        zIndex: _ctx.thumbsProps[item.enumValue].active ? 1 : undefined
      }),
      onTouchstart: _withModifiers($event => _ctx.start($event, item.enumValue), ["stop"]),
      onTouchmove: _withModifiers($event => _ctx.move($event, item.enumValue), ["stop"]),
      onTouchend: $event => _ctx.end(item.enumValue),
      onTouchcancel: $event => _ctx.end(item.enumValue)
    }, [_renderSlot(_ctx.$slots, "button", {
      currentValue: item.value
    }, () => [_createElementVNode("div", {
      class: _normalizeClass(_ctx.n('thumb-block')),
      style: _normalizeStyle({
        background: _ctx.thumbColor,
        height: _ctx.multiplySizeUnit(_ctx.thumbSize),
        width: _ctx.multiplySizeUnit(_ctx.thumbSize)
      })
    }, null, 6
    /* CLASS, STYLE */
    ), _createElementVNode("div", {
      class: _normalizeClass(_ctx.classes(_ctx.n('thumb-ripple'), [_ctx.thumbsProps[item.enumValue].active, _ctx.n('thumb-ripple--active')])),
      style: _normalizeStyle(_extends({
        background: _ctx.thumbColor
      }, _ctx.getRippleSize(item)))
    }, null, 6
    /* CLASS, STYLE */
    ), _createElementVNode("div", {
      class: _normalizeClass(_ctx.classes(_ctx.n('thumb-label'), [_ctx.showLabel(item.enumValue), _ctx.n('thumb-label--active')])),
      style: _normalizeStyle({
        background: _ctx.labelColor,
        color: _ctx.labelTextColor,
        height: _ctx.thumbSize === undefined ? _ctx.thumbSize : _ctx.multiplySizeUnit(_ctx.thumbSize, 2),
        width: _ctx.thumbSize === undefined ? _ctx.thumbSize : _ctx.multiplySizeUnit(_ctx.thumbSize, 2)
      })
    }, [_createElementVNode("span", null, _toDisplayString(item.value), 1
    /* TEXT */
    )], 6
    /* CLASS, STYLE */
    )])], 46
    /* CLASS, STYLE, PROPS, HYDRATE_EVENTS */
    , _hoisted_1);
  }), 128
  /* KEYED_FRAGMENT */
  ))], 6
  /* CLASS, STYLE */
  ), _createVNode(_component_var_form_details, {
    "error-message": _ctx.errorMessage,
    class: _normalizeClass(_ctx.n('form')),
    "var-slider-cover": ""
  }, null, 8
  /* PROPS */
  , ["error-message", "class"])], 2
  /* CLASS */
  );
}
export default defineComponent({
  render,
  name: 'VarSlider',
  components: {
    VarFormDetails
  },
  props,

  setup(props) {
    var {
      bindForm,
      form
    } = useForm();
    var {
      errorMessage,
      validateWithTrigger: vt,
      validate: v,
      resetValidation
    } = useValidation();

    var validate = () => v(props.rules, props.modelValue);

    var getThumbProps = () => ({
      startPosition: 0,
      currentLeft: 0,
      active: false,
      percentValue: 0
    });

    var validateWithTrigger = () => nextTick(() => vt(['onChange'], 'onChange', props.rules, props.modelValue));

    var sliderEl = ref(null);
    var maxWidth = ref(0);
    var isScroll = ref(false);
    var thumbsProps = reactive({
      [Thumbs.First]: getThumbProps(),
      [Thumbs.Second]: getThumbProps()
    });
    var unitWidth = computed(() => maxWidth.value / 100 * toNumber(props.step));
    var thumbList = computed(() => {
      var list = [{
        value: props.modelValue,
        enumValue: Thumbs.First
      }];

      if (props.range && isArray(props.modelValue)) {
        list = [{
          value: props.modelValue[0],
          enumValue: Thumbs.First
        }, {
          value: props.modelValue[1],
          enumValue: Thumbs.Second
        }];
      }

      return list;
    });

    var getRippleSize = item => {
      var size;

      if (props.thumbSize !== undefined) {
        size = thumbsProps[item.enumValue].active ? multiplySizeUnit(props.thumbSize, 3) : '0px';
      }

      return {
        height: size,
        width: size
      };
    };

    var showLabel = type => {
      if (props.labelVisible === 'always') return true;
      if (props.labelVisible === 'never') return false;
      return thumbsProps[type].active;
    };

    var getFillStyle = computed(() => {
      var {
        activeColor,
        range,
        modelValue
      } = props;
      var width = range && isArray(modelValue) ? Math.abs(modelValue[0] - modelValue[1]) : modelValue;
      var left = range && isArray(modelValue) ? Math.min(modelValue[0], modelValue[1]) : 0;
      return {
        width: width + "%",
        left: left + "%",
        background: activeColor
      };
    });
    var isDisabled = computed(() => props.disabled || (form == null ? void 0 : form.disabled.value));
    var isReadonly = computed(() => props.readonly || (form == null ? void 0 : form.readonly.value));

    var setPercent = (moveDistance, type) => {
      var rangeValue = [];
      var {
        step,
        range,
        modelValue,
        onChange
      } = props;
      var stepNumber = toNumber(step);
      var roundDistance = Math.round(moveDistance / unitWidth.value);
      var curValue = roundDistance * stepNumber;
      var prevValue = thumbsProps[type].percentValue;
      thumbsProps[type].percentValue = curValue / stepNumber;

      if (range && isArray(modelValue)) {
        rangeValue = type === Thumbs.First ? [curValue, modelValue[1]] : [modelValue[0], curValue];
      }

      if (prevValue !== curValue) {
        var value = range ? rangeValue : curValue;
        call(onChange, value);
        call(props['onUpdate:modelValue'], value);
        validateWithTrigger();
      }
    };

    var getType = offset => {
      if (!props.range) return Thumbs.First;
      var thumb1Distance = thumbsProps[Thumbs.First].percentValue * unitWidth.value;
      var thumb2Distance = thumbsProps[Thumbs.Second].percentValue * unitWidth.value;
      var offsetToThumb1 = Math.abs(offset - thumb1Distance);
      var offsetToThumb2 = Math.abs(offset - thumb2Distance);
      return offsetToThumb1 <= offsetToThumb2 ? Thumbs.First : Thumbs.Second;
    };

    var start = (event, type) => {
      if (!maxWidth.value) maxWidth.value = sliderEl.value.offsetWidth;
      if (isDisabled.value || isReadonly.value) return;
      call(props.onStart);
      isScroll.value = true;
      thumbsProps[type].startPosition = event.touches[0].clientX;
    };

    var move = (event, type) => {
      if (isDisabled.value || isReadonly.value || !isScroll.value) return;
      var moveDistance = event.touches[0].clientX - thumbsProps[type].startPosition + thumbsProps[type].currentLeft;
      thumbsProps[type].active = true;
      if (moveDistance <= 0) moveDistance = 0;else if (moveDistance >= maxWidth.value) moveDistance = maxWidth.value;
      setPercent(moveDistance, type);
    };

    var end = type => {
      var {
        range,
        modelValue,
        onEnd
      } = props;
      if (isDisabled.value || isReadonly.value) return;
      var rangeValue = [];
      thumbsProps[type].currentLeft = thumbsProps[type].percentValue * unitWidth.value;
      thumbsProps[type].active = false;
      var curValue = thumbsProps[type].percentValue;

      if (range && isArray(modelValue)) {
        rangeValue = type === Thumbs.First ? [curValue, modelValue[1]] : [modelValue[0], curValue];
      }

      call(onEnd, range ? rangeValue : curValue);
      isScroll.value = false;
    };

    var click = event => {
      if (isDisabled.value || isReadonly.value) return;
      if (event.target.closest('.var-slider__thumb')) return;
      var offset = event.clientX - getLeft(event.currentTarget);
      var type = getType(offset);
      setPercent(offset, type);
      end(type);
    };

    var stepValidator = () => {
      var stepNumber = toNumber(props.step);

      if (isNaN(stepNumber)) {
        console.warn('[Varlet] Slider: type of prop "step" should be Number');
        return false;
      }

      if (stepNumber < 1 || stepNumber > 100) {
        console.warn('[Varlet] Slider: "step" should be >= 0 and <= 100');
        return false;
      }

      if (parseInt("" + props.step, 10) !== stepNumber) {
        console.warn('[Varlet] Slider: "step" should be an Integer');
        return false;
      }

      return true;
    };

    var valueValidator = () => {
      var {
        range,
        modelValue
      } = props;

      if (range && !isArray(modelValue)) {
        console.error('[Varlet] Slider: "modelValue" should be an Array');
        return false;
      }

      if (!range && isArray(modelValue)) {
        console.error('[Varlet] Slider: "modelValue" should be a Number');
        return false;
      }

      if (range && isArray(modelValue) && modelValue.length < 2) {
        console.error('[Varlet] Slider: "modelValue" should have two value');
        return false;
      }

      return true;
    };

    var setProps = function (modelValue, step) {
      if (modelValue === void 0) {
        modelValue = props.modelValue;
      }

      if (step === void 0) {
        step = toNumber(props.step);
      }

      if (props.range && isArray(modelValue)) {
        thumbsProps[Thumbs.First].percentValue = modelValue[0] / step;
        thumbsProps[Thumbs.First].currentLeft = thumbsProps[Thumbs.First].percentValue * unitWidth.value;
        thumbsProps[Thumbs.Second].percentValue = modelValue[1] / step;
        thumbsProps[Thumbs.Second].currentLeft = thumbsProps[Thumbs.Second].percentValue * unitWidth.value;
      } else if (isNumber(modelValue)) {
        thumbsProps[Thumbs.First].currentLeft = modelValue / step * unitWidth.value;
      }
    };

    watch([() => props.modelValue, () => props.step], _ref => {
      var [modelValue, step] = _ref;
      if (!stepValidator() || !valueValidator() || isScroll.value) return;
      setProps(modelValue, toNumber(step));
    });
    watch(maxWidth, () => setProps());
    onMounted(() => {
      if (!stepValidator() || !valueValidator()) return;
      maxWidth.value = sliderEl.value.offsetWidth;
    });

    var reset = () => {
      var resetValue = props.range ? [0, 0] : 0;
      call(props['onUpdate:modelValue'], resetValue);
      resetValidation();
    };

    var sliderProvider = {
      reset,
      validate,
      resetValidation
    };
    call(bindForm, sliderProvider);
    return {
      n,
      classes,
      Thumbs,
      sliderEl,
      getFillStyle,
      isDisabled,
      errorMessage,
      thumbsProps,
      thumbList,
      multiplySizeUnit,
      toNumber,
      getRippleSize,
      showLabel,
      start,
      move,
      end,
      click
    };
  }

});