import VarIcon from '../icon';
import VarMenu from '../menu';
import VarChip from '../chip';
import VarFormDetails from '../form-details';
import { computed, defineComponent, ref, watch, nextTick } from 'vue';
import { isArray, isEmpty } from '@varlet/shared';
import { props } from './props';
import { useValidation, createNamespace, call } from '../utils/components';
import { useOptions } from './provide';
import { useForm } from '../form/provide';
import { getTop, toPxNum } from '../utils/elements';
var {
  n,
  classes
} = createNamespace('select');
import { renderSlot as _renderSlot, normalizeClass as _normalizeClass, createElementVNode as _createElementVNode, renderList as _renderList, Fragment as _Fragment, openBlock as _openBlock, createElementBlock as _createElementBlock, toDisplayString as _toDisplayString, createTextVNode as _createTextVNode, resolveComponent as _resolveComponent, withModifiers as _withModifiers, withCtx as _withCtx, createBlock as _createBlock, createCommentVNode as _createCommentVNode, createVNode as _createVNode, normalizeStyle as _normalizeStyle, pushScopeId as _pushScopeId, popScopeId as _popScopeId } from "vue";

var _withScopeId = n => (_pushScopeId(""), n = n(), _popScopeId(), n);

var _hoisted_1 = {
  key: 0
};
var _hoisted_2 = {
  key: 1
};
export function render(_ctx, _cache) {
  var _component_var_chip = _resolveComponent("var-chip");

  var _component_var_icon = _resolveComponent("var-icon");

  var _component_var_menu = _resolveComponent("var-menu");

  var _component_var_form_details = _resolveComponent("var-form-details");

  return _openBlock(), _createElementBlock("div", {
    class: _normalizeClass(_ctx.classes(_ctx.n(), 'var--box', [_ctx.formDisabled || _ctx.disabled, _ctx.n('--disabled')])),
    onClick: _cache[3] || (_cache[3] = function () {
      return _ctx.handleClick && _ctx.handleClick(...arguments);
    })
  }, [_createElementVNode("div", {
    class: _normalizeClass(_ctx.classes(_ctx.n('controller'), [_ctx.isFocus, _ctx.n('--focus')], [_ctx.errorMessage, _ctx.n('--error')], [_ctx.formDisabled || _ctx.disabled, _ctx.n('--disabled')])),
    style: _normalizeStyle({
      color: !_ctx.errorMessage ? _ctx.isFocus ? _ctx.focusColor : _ctx.blurColor : undefined
    })
  }, [_createElementVNode("div", {
    class: _normalizeClass(_ctx.classes(_ctx.n('icon'), [!_ctx.hint, _ctx.n('--non-hint')]))
  }, [_renderSlot(_ctx.$slots, "prepend-icon")], 2
  /* CLASS */
  ), _createVNode(_component_var_menu, {
    class: _normalizeClass(_ctx.n('menu')),
    "var-select-cover": "",
    "offset-y": _ctx.offsetY,
    show: _ctx.isFocus,
    "onUpdate:show": _cache[2] || (_cache[2] = $event => _ctx.isFocus = $event),
    onClose: _ctx.handleBlur
  }, {
    menu: _withCtx(() => [_createElementVNode("div", {
      ref: "menuEl",
      class: _normalizeClass(_ctx.n('scroller'))
    }, [_renderSlot(_ctx.$slots, "default")], 2
    /* CLASS */
    )]),
    default: _withCtx(() => [_createElementVNode("div", {
      class: _normalizeClass(_ctx.classes(_ctx.n('wrap'), [!_ctx.hint, _ctx.n('--non-hint')])),
      ref: "wrapEl",
      onClick: _cache[1] || (_cache[1] = function () {
        return _ctx.handleFocus && _ctx.handleFocus(...arguments);
      })
    }, [_createElementVNode("div", {
      class: _normalizeClass(_ctx.classes(_ctx.n('select'), [_ctx.errorMessage, _ctx.n('--error')], [_ctx.formDisabled || _ctx.disabled, _ctx.n('--disabled')])),
      style: _normalizeStyle({
        textAlign: _ctx.textAlign,
        color: _ctx.textColor
      })
    }, [_ctx.multiple ? (_openBlock(), _createElementBlock("div", _hoisted_1, [_ctx.chip ? (_openBlock(), _createElementBlock("div", {
      key: 0,
      class: _normalizeClass(_ctx.n('chips'))
    }, [(_openBlock(true), _createElementBlock(_Fragment, null, _renderList(_ctx.labels, l => {
      return _openBlock(), _createBlock(_component_var_chip, {
        class: _normalizeClass(_ctx.n('chip')),
        "var-select-cover": "",
        closable: "",
        size: "small",
        type: _ctx.errorMessage ? 'danger' : undefined,
        key: l,
        onClick: _cache[0] || (_cache[0] = _withModifiers(() => {}, ["stop"])),
        onClose: () => _ctx.handleClose(l)
      }, {
        default: _withCtx(() => [_createTextVNode(_toDisplayString(l), 1
        /* TEXT */
        )]),
        _: 2
        /* DYNAMIC */

      }, 1032
      /* PROPS, DYNAMIC_SLOTS */
      , ["class", "type", "onClose"]);
    }), 128
    /* KEYED_FRAGMENT */
    ))], 2
    /* CLASS */
    )) : (_openBlock(), _createElementBlock("div", {
      key: 1,
      class: _normalizeClass(_ctx.n('values'))
    }, _toDisplayString(_ctx.labels.join(_ctx.separator)), 3
    /* TEXT, CLASS */
    ))])) : (_openBlock(), _createElementBlock("span", _hoisted_2, _toDisplayString(_ctx.label), 1
    /* TEXT */
    )), _createVNode(_component_var_icon, {
      class: _normalizeClass(_ctx.classes(_ctx.n('arrow'), [_ctx.isFocus, _ctx.n('--arrow-rotate')])),
      "var-select-cover": "",
      name: "menu-down",
      transition: 300
    }, null, 8
    /* PROPS */
    , ["class"])], 6
    /* CLASS, STYLE */
    ), _createElementVNode("label", {
      class: _normalizeClass(_ctx.classes(_ctx.n('placeholder'), 'var--ellipsis', [_ctx.isFocus, _ctx.n('--focus')], [_ctx.errorMessage, _ctx.n('--error')], [_ctx.formDisabled || _ctx.disabled, _ctx.n('--disabled')], _ctx.computePlaceholderState(), [!_ctx.hint, _ctx.n('--placeholder-non-hint')])),
      style: _normalizeStyle({
        color: !_ctx.errorMessage ? _ctx.isFocus ? _ctx.focusColor : _ctx.blurColor : undefined
      })
    }, _toDisplayString(_ctx.placeholder), 7
    /* TEXT, CLASS, STYLE */
    )], 2
    /* CLASS */
    )]),
    _: 3
    /* FORWARDED */

  }, 8
  /* PROPS */
  , ["class", "offset-y", "show", "onClose"]), _createElementVNode("div", {
    class: _normalizeClass(_ctx.classes(_ctx.n('icon'), [!_ctx.hint, _ctx.n('--non-hint')]))
  }, [_renderSlot(_ctx.$slots, "append-icon", {}, () => [_ctx.clearable ? (_openBlock(), _createBlock(_component_var_icon, {
    key: 0,
    class: _normalizeClass(_ctx.n('clear-icon')),
    name: "close-circle",
    size: "14px",
    onClick: _ctx.handleClear
  }, null, 8
  /* PROPS */
  , ["class", "onClick"])) : _createCommentVNode("v-if", true)])], 2
  /* CLASS */
  )], 6
  /* CLASS, STYLE */
  ), _ctx.line ? (_openBlock(), _createElementBlock("div", {
    key: 0,
    class: _normalizeClass(_ctx.classes(_ctx.n('line'), [_ctx.formDisabled || _ctx.disabled, _ctx.n('--line-disabled')], [_ctx.errorMessage, _ctx.n('--line-error')])),
    style: _normalizeStyle({
      background: !_ctx.errorMessage ? _ctx.blurColor : undefined
    })
  }, [_createElementVNode("div", {
    class: _normalizeClass(_ctx.classes(_ctx.n('dot'), [_ctx.isFocus, _ctx.n('--spread')], [_ctx.formDisabled || _ctx.disabled, _ctx.n('--line-disabled')], [_ctx.errorMessage, _ctx.n('--line-error')])),
    style: _normalizeStyle({
      background: !_ctx.errorMessage ? _ctx.focusColor : undefined
    })
  }, null, 6
  /* CLASS, STYLE */
  )], 6
  /* CLASS, STYLE */
  )) : _createCommentVNode("v-if", true), _createVNode(_component_var_form_details, {
    "error-message": _ctx.errorMessage
  }, null, 8
  /* PROPS */
  , ["error-message"])], 2
  /* CLASS */
  );
}
export default defineComponent({
  render,
  name: 'VarSelect',
  components: {
    VarIcon,
    VarMenu,
    VarChip,
    VarFormDetails
  },
  props,

  setup(props) {
    var wrapEl = ref(null);
    var isFocus = ref(false);
    var multiple = computed(() => props.multiple);
    var focusColor = computed(() => props.focusColor);
    var label = ref('');
    var labels = ref([]);
    var wrapWidth = ref('0px');
    var offsetY = ref(0);
    var {
      bindForm,
      form
    } = useForm();
    var {
      length,
      options,
      bindOptions
    } = useOptions();
    var {
      errorMessage,
      validateWithTrigger: vt,
      validate: v,
      // expose
      resetValidation
    } = useValidation();
    var menuEl = ref(null);

    var computeLabel = () => {
      var {
        multiple,
        modelValue
      } = props;

      if (multiple) {
        var rawModelValue = modelValue;
        labels.value = rawModelValue.map(findLabel);
      }

      if (!multiple && !isEmpty(modelValue)) {
        label.value = findLabel(modelValue);
      }

      if (!multiple && isEmpty(modelValue)) {
        label.value = '';
      }
    };

    var validateWithTrigger = trigger => {
      nextTick(() => {
        var {
          validateTrigger,
          rules,
          modelValue
        } = props;
        vt(validateTrigger, trigger, rules, modelValue);
      });
    };

    var findValueOrLabel = _ref => {
      var {
        value,
        label
      } = _ref;

      if (value.value != null) {
        return value.value;
      }

      return label.value;
    };

    var findLabel = modelValue => {
      var _option$label$value, _option;

      var option = options.find(_ref2 => {
        var {
          value
        } = _ref2;
        return value.value === modelValue;
      });

      if (!option) {
        option = options.find(_ref3 => {
          var {
            label
          } = _ref3;
          return label.value === modelValue;
        });
      }

      return (_option$label$value = (_option = option) == null ? void 0 : _option.label.value) != null ? _option$label$value : '';
    };

    var computePlaceholderState = () => {
      var {
        hint,
        modelValue
      } = props;

      if (!hint && !isEmpty(modelValue)) {
        return n('--placeholder-hidden');
      }

      if (hint && (!isEmpty(modelValue) || isFocus.value)) {
        return n('--placeholder-hint');
      }
    };

    var getWrapWidth = () => {
      return wrapEl.value && window.getComputedStyle(wrapEl.value).width || '0px';
    };

    var getOffsetY = () => {
      var paddingTop = wrapEl.value && window.getComputedStyle(wrapEl.value).paddingTop || '0px';
      return toPxNum(paddingTop) * 1.5;
    };

    var handleFocus = () => {
      var {
        disabled,
        readonly,
        onFocus
      } = props;

      if (form != null && form.disabled.value || form != null && form.readonly.value || disabled || readonly) {
        return;
      }

      wrapWidth.value = getWrapWidth();
      offsetY.value = getOffsetY() + toPxNum(props.offsetY);
      isFocus.value = true;
      call(onFocus);
      validateWithTrigger('onFocus');
      detectBoundary();
    };

    var handleBlur = () => {
      var {
        disabled,
        readonly,
        onBlur
      } = props;

      if (form != null && form.disabled.value || form != null && form.readonly.value || disabled || readonly) {
        return;
      }

      call(onBlur);
      validateWithTrigger('onBlur');
    };

    var onSelect = option => {
      var {
        disabled,
        readonly,
        multiple,
        onChange
      } = props;

      if (form != null && form.disabled.value || form != null && form.readonly.value || disabled || readonly) {
        return;
      }

      var selectedValue = multiple ? options.filter(_ref4 => {
        var {
          selected
        } = _ref4;
        return selected.value;
      }).map(findValueOrLabel) : findValueOrLabel(option);
      call(props['onUpdate:modelValue'], selectedValue);
      call(onChange, selectedValue);
      validateWithTrigger('onChange');
      !multiple && (isFocus.value = false);
    };

    var handleClear = () => {
      var {
        disabled,
        readonly,
        multiple,
        clearable,
        onClear
      } = props;

      if (form != null && form.disabled.value || form != null && form.readonly.value || disabled || readonly || !clearable) {
        return;
      }

      var changedModelValue = multiple ? [] : undefined;
      call(props['onUpdate:modelValue'], changedModelValue);
      call(onClear, changedModelValue);
      validateWithTrigger('onClear');
    };

    var handleClick = e => {
      var {
        disabled,
        onClick
      } = props;

      if (form != null && form.disabled.value || disabled) {
        return;
      }

      call(onClick, e);
      validateWithTrigger('onClick');
    };

    var handleClose = text => {
      var {
        disabled,
        readonly,
        modelValue,
        onClose
      } = props;

      if (form != null && form.disabled.value || form != null && form.readonly.value || disabled || readonly) {
        return;
      }

      var rawModelValue = modelValue;
      var option = options.find(_ref5 => {
        var {
          label
        } = _ref5;
        return label.value === text;
      });
      var currentModelValue = rawModelValue.filter(value => {
        var _value$value;

        return value !== ((_value$value = option.value.value) != null ? _value$value : option.label.value);
      });
      call(props['onUpdate:modelValue'], currentModelValue);
      call(onClose, currentModelValue);
      validateWithTrigger('onClose');
    };

    var syncOptions = () => {
      var {
        multiple,
        modelValue
      } = props;

      if (multiple) {
        var rawModelValue = modelValue;
        options.forEach(option => option.sync(rawModelValue.includes(findValueOrLabel(option))));
      } else {
        options.forEach(option => option.sync(modelValue === findValueOrLabel(option)));
      }

      computeLabel();
    }; // expose


    var focus = () => {
      wrapWidth.value = getWrapWidth();
      offsetY.value = getOffsetY() + toPxNum(props.offsetY);
      isFocus.value = true;
      detectBoundary();
    }; // expose


    var blur = () => {
      isFocus.value = false;
    }; // expose


    var validate = () => v(props.rules, props.modelValue); // expose


    var reset = () => {
      call(props['onUpdate:modelValue'], props.multiple ? [] : undefined);
      resetValidation();
    };

    var detectBoundary = () => {
      var {
        body
      } = document;
      var bodyScrollHeight = body.scrollHeight;
      nextTick(() => {
        var _menuEl$value;

        var {
          offsetHeight: menuOffsetHeight
        } = (_menuEl$value = menuEl.value) == null ? void 0 : _menuEl$value.parentElement;
        var wrapOffsetTop = getTop(wrapEl.value);

        if (wrapOffsetTop + offsetY.value < 0) {
          offsetY.value = getOffsetY();
        }

        if (menuOffsetHeight + wrapOffsetTop + offsetY.value > bodyScrollHeight) {
          offsetY.value -= menuOffsetHeight - getOffsetY();
        }
      });
    };

    watch(() => props.multiple, () => {
      var {
        multiple,
        modelValue
      } = props;

      if (multiple && !isArray(modelValue)) {
        throw Error('The modelValue must be an array when multiple is true');
      }
    });
    watch(() => props.modelValue, syncOptions, {
      deep: true
    });
    watch(() => length.value, syncOptions);
    var selectProvider = {
      wrapWidth: computed(() => wrapWidth.value),
      multiple,
      focusColor,
      onSelect,
      reset,
      validate,
      resetValidation
    };
    bindOptions(selectProvider);
    call(bindForm, selectProvider);
    return {
      wrapEl,
      offsetY,
      isFocus,
      errorMessage,
      formDisabled: form == null ? void 0 : form.disabled,
      label,
      labels,
      menuEl,
      n,
      classes,
      computePlaceholderState,
      handleFocus,
      handleBlur,
      handleClear,
      handleClick,
      handleClose,
      reset,
      validate,
      resetValidation,
      focus,
      blur
    };
  }

});