function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

import VarSticky from '../sticky';
import { defineComponent, watch, ref, computed, Transition, onMounted, onUnmounted } from 'vue';
import { props } from './props';
import { useTabList } from './provide';
import { isNumber } from '@varlet/shared';
import { linear } from '../utils/shared';
import { toSizeUnit, scrollTo, doubleRaf } from '../utils/elements';
import { createNamespace, call } from '../utils/components';
var {
  n,
  classes
} = createNamespace('tabs');
import { renderSlot as _renderSlot, normalizeClass as _normalizeClass, normalizeStyle as _normalizeStyle, createElementVNode as _createElementVNode, mergeProps as _mergeProps, resolveDynamicComponent as _resolveDynamicComponent, withCtx as _withCtx, openBlock as _openBlock, createBlock as _createBlock } from "vue";
export function render(_ctx, _cache) {
  return _openBlock(), _createBlock(_resolveDynamicComponent(_ctx.sticky ? 'var-sticky' : _ctx.Transition), {
    "offset-top": _ctx.sticky ? _ctx.offsetTop : null
  }, {
    default: _withCtx(() => [_createElementVNode("div", _mergeProps({
      class: _ctx.classes(_ctx.n(), 'var--box', _ctx.n("--item-" + _ctx.itemDirection), _ctx.n("--layout-" + _ctx.layoutDirection + "-padding"), [_ctx.elevation, 'var-elevation--4'], [_ctx.fixedBottom, _ctx.n('--fixed-bottom')], [_ctx.safeArea, _ctx.n('--safe-area')]),
      style: {
        background: _ctx.color
      }
    }, _ctx.$attrs), [_createElementVNode("div", {
      ref: "scrollerEl",
      class: _normalizeClass(_ctx.classes(_ctx.n('tab-wrap'), [_ctx.scrollable, _ctx.n("--layout-" + _ctx.layoutDirection + "-scrollable")], _ctx.n("--layout-" + _ctx.layoutDirection)))
    }, [_renderSlot(_ctx.$slots, "default"), _createElementVNode("div", {
      class: _normalizeClass(_ctx.classes(_ctx.n('indicator'), _ctx.n("--layout-" + _ctx.layoutDirection + "-indicator"))),
      style: _normalizeStyle({
        width: _ctx.layoutDirection === 'horizontal' ? _ctx.indicatorWidth : _ctx.toSizeUnit(_ctx.indicatorSize),
        height: _ctx.layoutDirection === 'horizontal' ? _ctx.toSizeUnit(_ctx.indicatorSize) : _ctx.indicatorHeight,
        transform: _ctx.layoutDirection === 'horizontal' ? "translateX(" + _ctx.indicatorX + ")" : "translateY(" + _ctx.indicatorY + ")",
        background: _ctx.indicatorColor || _ctx.activeColor
      })
    }, null, 6
    /* CLASS, STYLE */
    )], 2
    /* CLASS */
    )], 16
    /* FULL_PROPS */
    )]),
    _: 3
    /* FORWARDED */

  }, 8
  /* PROPS */
  , ["offset-top"]);
}
export default defineComponent({
  render,
  name: 'VarTabs',
  components: {
    VarSticky
  },
  inheritAttrs: false,
  props,

  setup(props) {
    var indicatorWidth = ref('0px');
    var indicatorHeight = ref('0px');
    var indicatorX = ref('0px');
    var indicatorY = ref('0px');
    var scrollable = ref(false);
    var scrollerEl = ref(null);
    var active = computed(() => props.active);
    var activeColor = computed(() => props.activeColor);
    var inactiveColor = computed(() => props.inactiveColor);
    var disabledColor = computed(() => props.disabledColor);
    var itemDirection = computed(() => props.itemDirection);
    var {
      tabList,
      bindTabList,
      length
    } = useTabList();

    var onTabClick = tab => {
      var _tab$name$value;

      var currentActive = (_tab$name$value = tab.name.value) != null ? _tab$name$value : tab.index.value;
      var {
        active,
        onChange,
        onClick
      } = props;
      call(props['onUpdate:active'], currentActive);
      call(onClick, currentActive);
      currentActive !== active && call(onChange, currentActive);
    };

    var matchName = () => {
      return tabList.find(_ref => {
        var {
          name
        } = _ref;
        return props.active === name.value;
      });
    };

    var matchIndex = activeIndex => {
      return tabList.find(_ref2 => {
        var {
          index
        } = _ref2;
        return (activeIndex != null ? activeIndex : props.active) === index.value;
      });
    };

    var matchBoundary = () => {
      if (length.value === 0) {
        return;
      }

      var {
        active
      } = props;

      if (isNumber(active)) {
        var activeIndex = active > length.value - 1 ? length.value - 1 : 0;
        call(props['onUpdate:active'], activeIndex);
        return matchIndex(activeIndex);
      }
    };

    var watchScrollable = () => {
      scrollable.value = tabList.length >= 5;
    };

    var moveIndicator = _ref3 => {
      var {
        element
      } = _ref3;
      var el = element.value;

      if (props.layoutDirection === 'horizontal') {
        indicatorWidth.value = (el == null ? void 0 : el.offsetWidth) + "px";
        indicatorX.value = (el == null ? void 0 : el.offsetLeft) + "px";
      } else {
        indicatorHeight.value = (el == null ? void 0 : el.offsetHeight) + "px";
        indicatorY.value = (el == null ? void 0 : el.offsetTop) + "px";
      }
    };

    var scrollToCenter = _ref4 => {
      var {
        element
      } = _ref4;

      if (!scrollable.value) {
        return;
      }

      var scroller = scrollerEl.value;
      var el = element.value;

      if (props.layoutDirection === 'horizontal') {
        var left = el.offsetLeft + el.offsetWidth / 2 - scroller.offsetWidth / 2;
        scrollTo(scroller, {
          left,
          animation: linear
        });
      } else {
        var top = el.offsetTop + el.offsetHeight / 2 - scroller.offsetHeight / 2;
        scrollTo(scroller, {
          top,
          animation: linear
        });
      }
    }; // expose


    var resize = () => {
      var tab = matchName() || matchIndex() || matchBoundary();

      if (!tab || tab.disabled.value) {
        return;
      }

      watchScrollable();
      moveIndicator(tab);
      scrollToCenter(tab);
    };

    var tabsProvider = {
      active,
      activeColor,
      inactiveColor,
      disabledColor,
      itemDirection,
      resize,
      onTabClick
    };
    bindTabList(tabsProvider);
    watch(() => length.value, /*#__PURE__*/_asyncToGenerator(function* () {
      yield doubleRaf();
      resize();
    }));
    watch(() => props.active, resize);
    onMounted(() => window.addEventListener('resize', resize));
    onUnmounted(() => window.removeEventListener('resize', resize));
    return {
      indicatorWidth,
      indicatorHeight,
      indicatorX,
      indicatorY,
      scrollable,
      scrollerEl,
      Transition,
      toSizeUnit,
      n,
      classes,
      resize
    };
  }

});