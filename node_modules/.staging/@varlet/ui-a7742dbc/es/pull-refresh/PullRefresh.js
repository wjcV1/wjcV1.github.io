function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

import VarIcon from '../icon';
import { defineComponent, ref, computed, watch, onMounted } from 'vue';
import { getParentScroller, getScrollTop } from '../utils/elements';
import { props } from './props';
import { toNumber } from '@varlet/shared';
import { createNamespace } from '../utils/components';
var {
  n,
  classes
} = createNamespace('pull-refresh');
var MAX_DISTANCE = 100;
var CONTROL_POSITION = -50;
var ICON_TRANSITION = 150;
import { resolveComponent as _resolveComponent, normalizeClass as _normalizeClass, createVNode as _createVNode, normalizeStyle as _normalizeStyle, createElementVNode as _createElementVNode, renderSlot as _renderSlot, openBlock as _openBlock, createElementBlock as _createElementBlock } from "vue";
export function render(_ctx, _cache) {
  var _component_var_icon = _resolveComponent("var-icon");

  return _openBlock(), _createElementBlock("div", {
    ref: "freshNode",
    class: _normalizeClass(_ctx.n()),
    onTouchstart: _cache[0] || (_cache[0] = function () {
      return _ctx.touchStart && _ctx.touchStart(...arguments);
    }),
    onTouchmove: _cache[1] || (_cache[1] = function () {
      return _ctx.touchMove && _ctx.touchMove(...arguments);
    }),
    onTouchend: _cache[2] || (_cache[2] = function () {
      return _ctx.touchEnd && _ctx.touchEnd(...arguments);
    }),
    onTouchcancel: _cache[3] || (_cache[3] = function () {
      return _ctx.touchEnd && _ctx.touchEnd(...arguments);
    })
  }, [_createElementVNode("div", {
    class: _normalizeClass(_ctx.classes(_ctx.n('control'), 'var-elevation--2', [_ctx.isSuccess, _ctx.n('control-success')])),
    style: _normalizeStyle(_ctx.controlStyle)
  }, [_createVNode(_component_var_icon, {
    name: _ctx.iconName,
    transition: _ctx.ICON_TRANSITION,
    class: _normalizeClass(_ctx.classes(_ctx.n('icon'), [_ctx.refreshStatus === 'loading' && _ctx.iconHasChanged, _ctx.n('animation')])),
    "var-pull-refresh-cover": ""
  }, null, 8
  /* PROPS */
  , ["name", "transition", "class"])], 6
  /* CLASS, STYLE */
  ), _renderSlot(_ctx.$slots, "default")], 34
  /* CLASS, HYDRATE_EVENTS */
  );
}
export default defineComponent({
  render,
  name: 'VarPullRefresh',
  components: {
    VarIcon
  },
  props,

  setup(props) {
    var scroller;
    var changing;
    var freshNode = ref(null);
    var startPosition = ref(0);
    var distance = ref(CONTROL_POSITION);
    var iconName = ref('arrow-down');
    var refreshStatus = ref('default');
    var isEnd = ref(false); // https://github.com/varletjs/varlet/issues/509

    var iconHasChanged = ref(true);
    var isTouchable = computed(() => refreshStatus.value !== 'loading' && refreshStatus.value !== 'success' && !props.disabled);
    var controlStyle = computed(() => ({
      transform: "translate3d(0px, " + distance.value + "px, 0px) translate(-50%, 0)",
      transition: isEnd.value ? "transform " + props.animationDuration + "ms" : undefined,
      background: isSuccess.value ? props.successBgColor : props.bgColor,
      color: isSuccess.value ? props.successColor : props.color
    }));
    var isSuccess = computed(() => refreshStatus.value === 'success');

    var changeIcon = () => {
      return new Promise(resolve => {
        window.setTimeout(() => {
          iconHasChanged.value = true;
          resolve();
        }, ICON_TRANSITION);
      });
    };

    var touchStart = event => {
      if (!isTouchable.value) return;
      refreshStatus.value = 'pulling';
      startPosition.value = event.touches[0].clientY;
    };

    var touchMove = event => {
      var scrollTop = getScrollTop(scroller);
      if (scrollTop > 0 || !isTouchable.value) return;
      if (scrollTop === 0 && distance.value > CONTROL_POSITION) event.cancelable && event.preventDefault();
      var moveDistance = (event.touches[0].clientY - startPosition.value) / 2 + CONTROL_POSITION;
      distance.value = moveDistance >= MAX_DISTANCE ? MAX_DISTANCE : moveDistance;

      if (distance.value >= MAX_DISTANCE * 0.2) {
        iconHasChanged.value = false;
        iconName.value = 'refresh';
        changing = changeIcon();
      } else {
        iconName.value = 'arrow-down';
      }
    };

    var touchEnd = /*#__PURE__*/function () {
      var _ref = _asyncToGenerator(function* () {
        if (!isTouchable.value) return;
        isEnd.value = true;

        if (distance.value >= MAX_DISTANCE * 0.2) {
          var _props$onUpdateModel;

          yield changing;
          refreshStatus.value = 'loading';
          distance.value = MAX_DISTANCE * 0.3;
          (_props$onUpdateModel = props['onUpdate:modelValue']) == null ? void 0 : _props$onUpdateModel.call(props, true);
          props.onRefresh == null ? void 0 : props.onRefresh();
        } else {
          refreshStatus.value = 'loosing';
          iconName.value = 'arrow-down';
          distance.value = CONTROL_POSITION;
          setTimeout(() => {
            isEnd.value = false;
          }, toNumber(props.animationDuration));
        }
      });

      return function touchEnd() {
        return _ref.apply(this, arguments);
      };
    }();

    var reset = () => {
      setTimeout(() => {
        refreshStatus.value = 'default';
        iconName.value = 'arrow-down';
        isEnd.value = false;
      }, toNumber(props.animationDuration));
    };

    watch(() => props.modelValue, newValue => {
      if (newValue === false) {
        isEnd.value = true;
        refreshStatus.value = 'success';
        iconName.value = 'checkbox-marked-circle';
        setTimeout(() => {
          distance.value = CONTROL_POSITION;
          reset();
        }, toNumber(props.successDuration));
      }
    });
    onMounted(() => {
      scroller = getParentScroller(freshNode.value);
    });
    return {
      n,
      classes,
      iconHasChanged,
      ICON_TRANSITION,
      refreshStatus,
      freshNode,
      touchStart,
      touchMove,
      touchEnd,
      iconName,
      controlStyle,
      isSuccess
    };
  }

});